<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GEMM 算法优化 | diefish's blog</title><meta name=keywords content="CS,HPC"><meta name=description content="本文简要介绍通用矩阵乘（GEMM，General Matrix Multiplication）优化的基本概念和方法。GEMM 是 HPC 领域中最基础且计算密集型的工作负载之一。在人工智能、科学模拟和图像处理等领域，它的性能直接影响着整个应用程序的效率。虽然其数学概念简单，但高效的 GEMM 实现却需要对计算机体系结构有深刻的理解，包括缓存、SIMD 指令集和并行化技术。
Naive GEMM
GEMM 通常定义为 $ C = A \times B $，对于矩阵 $ A \in \mathbb{R}^{M \times K} $，矩阵 $ B \in \mathbb{R}^{K \times N} $，其乘积矩阵 $ C\in \mathbb{R}^{M \times N} $ 可以表示为
$$ 

C_{i,j} = \sum_{k=0}^{K-1} A_{i,k}\times B_{k,j} 

 $$
对应的朴素代码通常如下（默认行主序存储）：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


void gemm_naive(int M, int N, int K, const float* A, const float* B, float* C) {
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            C[i][j] = 0.0f; // 初始化 C[i][j]
        }
    }
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            for (int k = 0; k < K; ++k) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}


分析："><meta name=author content="diefish"><link rel=canonical href=https://diefish1024.github.io/posts/hpc/gemm-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://diefish1024.github.io/images/avatar.jpg><link rel=icon type=image/png sizes=16x16 href=https://diefish1024.github.io/images/avatar.jpg><link rel=icon type=image/png sizes=32x32 href=https://diefish1024.github.io/images/avatar.jpg><link rel=apple-touch-icon href=https://diefish1024.github.io/images/avatar.jpg><link rel=mask-icon href=https://diefish1024.github.io/images/avatar.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://diefish1024.github.io/posts/hpc/gemm-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://diefish1024.github.io/posts/hpc/gemm-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"><meta property="og:site_name" content="diefish's blog"><meta property="og:title" content="GEMM 算法优化"><meta property="og:description" content="本文简要介绍通用矩阵乘（GEMM，General Matrix Multiplication）优化的基本概念和方法。GEMM 是 HPC 领域中最基础且计算密集型的工作负载之一。在人工智能、科学模拟和图像处理等领域，它的性能直接影响着整个应用程序的效率。虽然其数学概念简单，但高效的 GEMM 实现却需要对计算机体系结构有深刻的理解，包括缓存、SIMD 指令集和并行化技术。
Naive GEMM GEMM 通常定义为 $ C = A \times B $，对于矩阵 $ A \in \mathbb{R}^{M \times K} $，矩阵 $ B \in \mathbb{R}^{K \times N} $，其乘积矩阵 $ C\in \mathbb{R}^{M \times N} $ 可以表示为 $$ C_{i,j} = \sum_{k=0}^{K-1} A_{i,k}\times B_{k,j} $$ 对应的朴素代码通常如下（默认行主序存储）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 void gemm_naive(int M, int N, int K, const float* A, const float* B, float* C) { for (int i = 0; i < M; ++i) { for (int j = 0; j < N; ++j) { C[i][j] = 0.0f; // 初始化 C[i][j] } } for (int i = 0; i < M; ++i) { for (int j = 0; j < N; ++j) { for (int k = 0; k < K; ++k) { C[i][j] += A[i][k] * B[k][j]; } } } } 分析："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-12T10:43:00+08:00"><meta property="article:modified_time" content="2025-09-12T10:43:00+08:00"><meta property="article:tag" content="CS"><meta property="article:tag" content="HPC"><meta property="og:image" content="https://diefish1024.github.io/images/avatar.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://diefish1024.github.io/images/avatar.jpg"><meta name=twitter:title content="GEMM 算法优化"><meta name=twitter:description content="本文简要介绍通用矩阵乘（GEMM，General Matrix Multiplication）优化的基本概念和方法。GEMM 是 HPC 领域中最基础且计算密集型的工作负载之一。在人工智能、科学模拟和图像处理等领域，它的性能直接影响着整个应用程序的效率。虽然其数学概念简单，但高效的 GEMM 实现却需要对计算机体系结构有深刻的理解，包括缓存、SIMD 指令集和并行化技术。
Naive GEMM
GEMM 通常定义为 $ C = A \times B $，对于矩阵 $ A \in \mathbb{R}^{M \times K} $，矩阵 $ B \in \mathbb{R}^{K \times N} $，其乘积矩阵 $ C\in \mathbb{R}^{M \times N} $ 可以表示为
$$ 

C_{i,j} = \sum_{k=0}^{K-1} A_{i,k}\times B_{k,j} 

 $$
对应的朴素代码通常如下（默认行主序存储）：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


void gemm_naive(int M, int N, int K, const float* A, const float* B, float* C) {
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            C[i][j] = 0.0f; // 初始化 C[i][j]
        }
    }
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            for (int k = 0; k < K; ++k) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}


分析："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://diefish1024.github.io/posts/"},{"@type":"ListItem","position":2,"name":"HPC","item":"https://diefish1024.github.io/posts/hpc/"},{"@type":"ListItem","position":3,"name":"GEMM 算法优化","item":"https://diefish1024.github.io/posts/hpc/gemm-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GEMM 算法优化","name":"GEMM 算法优化","description":"本文简要介绍通用矩阵乘（GEMM，General Matrix Multiplication）优化的基本概念和方法。GEMM 是 HPC 领域中最基础且计算密集型的工作负载之一。在人工智能、科学模拟和图像处理等领域，它的性能直接影响着整个应用程序的效率。虽然其数学概念简单，但高效的 GEMM 实现却需要对计算机体系结构有深刻的理解，包括缓存、SIMD 指令集和并行化技术。\nNaive GEMM GEMM 通常定义为 $ C = A \\times B $，对于矩阵 $ A \\in \\mathbb{R}^{M \\times K} $，矩阵 $ B \\in \\mathbb{R}^{K \\times N} $，其乘积矩阵 $ C\\in \\mathbb{R}^{M \\times N} $ 可以表示为 $$ C_{i,j} = \\sum_{k=0}^{K-1} A_{i,k}\\times B_{k,j} $$ 对应的朴素代码通常如下（默认行主序存储）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void gemm_naive(int M, int N, int K, const float* A, const float* B, float* C) { for (int i = 0; i \u0026lt; M; ++i) { for (int j = 0; j \u0026lt; N; ++j) { C[i][j] = 0.0f; // 初始化 C[i][j] } } for (int i = 0; i \u0026lt; M; ++i) { for (int j = 0; j \u0026lt; N; ++j) { for (int k = 0; k \u0026lt; K; ++k) { C[i][j] += A[i][k] * B[k][j]; } } } } 分析：\n","keywords":["CS","HPC"],"articleBody":"本文简要介绍通用矩阵乘（GEMM，General Matrix Multiplication）优化的基本概念和方法。GEMM 是 HPC 领域中最基础且计算密集型的工作负载之一。在人工智能、科学模拟和图像处理等领域，它的性能直接影响着整个应用程序的效率。虽然其数学概念简单，但高效的 GEMM 实现却需要对计算机体系结构有深刻的理解，包括缓存、SIMD 指令集和并行化技术。\nNaive GEMM GEMM 通常定义为 $ C = A \\times B $，对于矩阵 $ A \\in \\mathbb{R}^{M \\times K} $，矩阵 $ B \\in \\mathbb{R}^{K \\times N} $，其乘积矩阵 $ C\\in \\mathbb{R}^{M \\times N} $ 可以表示为 $$ C_{i,j} = \\sum_{k=0}^{K-1} A_{i,k}\\times B_{k,j} $$ 对应的朴素代码通常如下（默认行主序存储）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void gemm_naive(int M, int N, int K, const float* A, const float* B, float* C) { for (int i = 0; i \u003c M; ++i) { for (int j = 0; j \u003c N; ++j) { C[i][j] = 0.0f; // 初始化 C[i][j] } } for (int i = 0; i \u003c M; ++i) { for (int j = 0; j \u003c N; ++j) { for (int k = 0; k \u003c K; ++k) { C[i][j] += A[i][k] * B[k][j]; } } } } 分析：\n浮点运算总数（FLOPs）：\n对于每个 $ C_{i,j} $ 元素，需要执行 $ K $ 次乘法和 $ K $ 次加法。 总共有 $ M \\times N $ 个 $ C_{i,j} $ 元素。 总操作数约为 $ 2 \\times M \\times N \\times K $ 次浮点运算。 内存访问总数：忽略循环变量和指令的开销。\n矩阵 $ C $ 的初始化需要 $ M \\times N $ 次写入；循环中矩阵 $ A $ 和矩阵 $ B $ 分别被读取 $ M \\times N \\times K $ 次，矩阵 $ C $ 被读取和写入共 $ 2 \\times M \\times N \\times K $ 次。 总内存访问次数约为 $ 4 M N K + M N $。 Why Slow? 尽管代码简洁，但这种实现方式存在严重的性能瓶颈：\n缓存利用率低：对 B[k][j 的访问大概率导致缓存未命中。由于 B 是行主序存储，每次迭代 k 都会跳到 B 矩阵的下一行，这导致巨大的内存跨越，破坏了空间局部性。\n缺乏 SIMD 向量化潜力：编译器很难将这种混合访问模式有效向量化，因为对 $ B $ 的访问模式不佳。\n算法本身时间复杂度为 $ O(N^{3}) $。\n对这样的矩阵乘的算法优化可分为两类：\n基于算法分析的方法：根据矩阵乘计算特性，从数学角度优化，典型的算法包括 Strassen 算法 和 Coppersmith–Winograd 算法。 基于软件优化的方法：根据计算机存储系统的层次结构特性，选择性地调整计算顺序，主要有循环拆分向量化、内存重排等。 数学角度的优化暂且不在本文的讨论范围内，有机会将单独介绍，下面给出计算机体系结构角度的一些优化角度。\n1 × 4 Register Blocking 参考 how to optimize gemm 一文，我们把输出的计算按照列拆分成若干个 $ 1 \\times 4 $ 的小块，通过一次性处理 $ C $ 的一小块内存来减少内存操作，最大化寄存器的利用率。\n与其一次计算 $ C_{i,j} $ 一个元素，不如一次性计算 $ C_{i, j\\sim j+3} $ 四个连续元素，这很好地利用了 $ C $ 矩阵行内的空间局部性。把这四个元素加载到寄存器，可以大大减少对主存的访问次数。\n下文我们将最内层的循环称为微内核（micro kernel），比如 AddDot1x4 就是一个微内核。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // AddDot1x4: 计算 C 的一个 1x4 块（按行主序） // Ai 指向 A 的第 i 行起始；Bj 指向 B 的第 j 列所在的起始位置；Cij 指向 C[i][j] inline void AddDot1x4(int K, const float* Ai, const float* Bj, float* Cij, int N) { float c0 = 0.0f, c1 = 0.0f, c2 = 0.0f, c3 = 0.0f; for (int k = 0; k \u003c K; ++k) { float a = Ai[k]; const float* bk = Bj + k * N; // B[k][j..j+3] c0 += a * bk[0]; c1 += a * bk[1]; c2 += a * bk[2]; c3 += a * bk[3]; } Cij[0] = c0; Cij[1] = c1; Cij[2] = c2; Cij[3] = c3; } void gemm_1x4_blocked(int M, int N, int K, const float* A, const float* B, float* C) { for (int i = 0; i \u003c M; ++i) { const float* Ai = \u0026A[i * K]; for (int j = 0; j \u003c N; j += 4) { int w = std::min(4, N - j); if (w == 4) { AddDot1x4(K, Ai, \u0026B[j], \u0026C[i * N + j], N); } else { // 处理尾部 \u003c4 列 for (int jj = 0; jj \u003c w; ++jj) { float acc = 0.f; for (int k = 0; k \u003c K; ++k) acc += Ai[k] * B[k * N + (j + jj)]; C[i * N + j + jj] = acc; } } } } } 分析：\nFLOPs：仍为 $ 2 M N K $。 内存访问：（以元素计，忽略缓存命中） 读取 $ A $：对每个 $ 1 \\times 4 $ 块，每次 $ K $ 次，共 $ \\frac{M N}{4} \\times K = \\frac{M N K}{4} $。 读取 $ B $：每次 $ 4K $，共 $ \\frac{M N}{4} \\times 4K = M N K $。 写入 $ C $：每块写 $ 4 $ 次，共 $ M N $。无需读取 $ C $（寄存器累加后赋值）。 合计：$ \\frac{1}{4} M N K + 1 \\cdot M N K + M N = 1.25\\, M N K + M N $。 与 naive 相比，$ A $ 的读取减少了 $ 4 \\times $（复用到 4 个连续列），$ B $ 的读取次数相同但连续访问更友好，$ C $ 的访存从每次迭代读写降为仅写一次。\n加速比：\n在内存带宽主导的 Roofline 模型 下，性能与内存访问次数近似成反比，因此加速比为 $$ S_{\\text{1x4}} \\approx \\frac{4 M N K + M N}{1.25 M N K + M N} \\approx \\frac{4}{1.25} = 3.2 \\quad (K \\gg 1) $$\nLoop Unrolling and Pointer Optimization 为了进一步优化，我们在 AddDot1x4 内部使用指针迭代与循环展开，减少地址计算和分支开销，提升指令级并行性与寄存器利用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 inline void AddDot1x4_unroll4(int K, const float* Ai, const float* Bj, float* Cij, int N) { float c0 = 0.f, c1 = 0.f, c2 = 0.f, c3 = 0.f; const float* a = Ai; const float* b = Bj; int k = 0; for (; k + 3 \u003c K; k += 4) { float a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3]; const float* b0 = b + 0 * N; const float* b1 = b + 1 * N; const float* b2 = b + 2 * N; const float* b3 = b + 3 * N; c0 += a0 * b0[0] + a1 * b1[0] + a2 * b2[0] + a3 * b3[0]; c1 += a0 * b0[1] + a1 * b1[1] + a2 * b2[1] + a3 * b3[1]; c2 += a0 * b0[2] + a1 * b1[2] + a2 * b2[2] + a3 * b3[2]; c3 += a0 * b0[3] + a1 * b1[3] + a2 * b2[3] + a3 * b3[3]; a += 4; b += 4 * N; } for (; k \u003c K; ++k) { float av = *a++; const float* bk = b; b += N; c0 += av * bk[0]; c1 += av * bk[1]; c2 += av * bk[2]; c3 += av * bk[3]; } Cij[0] = c0; Cij[1] = c1; Cij[2] = c2; Cij[3] = c3; } 分析：\nFLOPs：仍为 $ 2 M N K $。 内存访问：与 $ 1 \\times 4 $ 相同（$ 1.25\\, M N K + M N $），仅减少了地址计算和分支开销。 加速比：\n内存主导：与 $ 1 \\times 4 $ 相同，约 $ 3.2 \\times $。 计算主导：循环展开可进一步减少指令开销，常见提升在 $ 5\\% \\sim 15\\% $ 范围（与编译器和微架构相关）。 4 × 4 Register Blocking 不难意识到，用一样的逻辑可以把上面的寄存器分块从 $ 1 \\times 4 $ 扩展到 $ 4 \\times 4 $。这样可以进一步减少内存操作，提高效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // AddDot4x4: 计算 C 的一个 4x4 块（行主序，传入 C 的起始为 C[i][j]） inline void AddDot4x4(int K, const float* Aij, const float* Bkj, float* Cij, int N, int Kstride) { float c00=0.f,c01=0.f,c02=0.f,c03=0.f, c10=0.f,c11=0.f,c12=0.f,c13=0.f, c20=0.f,c21=0.f,c22=0.f,c23=0.f, c30=0.f,c31=0.f,c32=0.f,c33=0.f; const float* a0 = Aij + 0 * Kstride; const float* a1 = Aij + 1 * Kstride; const float* a2 = Aij + 2 * Kstride; const float* a3 = Aij + 3 * Kstride; for (int k = 0; k \u003c K; ++k) { float a0k = a0[k], a1k = a1[k], a2k = a2[k], a3k = a3[k]; const float* bk = Bkj + k * N; float b0 = bk[0], b1 = bk[1], b2 = bk[2], b3 = bk[3]; c00 += a0k * b0; c01 += a0k * b1; c02 += a0k * b2; c03 += a0k * b3; c10 += a1k * b0; c11 += a1k * b1; c12 += a1k * b2; c13 += a1k * b3; c20 += a2k * b0; c21 += a2k * b1; c22 += a2k * b2; c23 += a2k * b3; c30 += a3k * b0; c31 += a3k * b1; c32 += a3k * b2; c33 += a3k * b3; } Cij[0*N+0]=c00; Cij[0*N+1]=c01; Cij[0*N+2]=c02; Cij[0*N+3]=c03; Cij[1*N+0]=c10; Cij[1*N+1]=c11; Cij[1*N+2]=c12; Cij[1*N+3]=c13; Cij[2*N+0]=c20; Cij[2*N+1]=c21; Cij[2*N+2]=c22; Cij[2*N+3]=c23; Cij[3*N+0]=c30; Cij[3*N+1]=c31; Cij[3*N+2]=c32; Cij[3*N+3]=c33; } 分析：\nFLOPs：仍为 $ 2 M N K $。 内存访问（元素计）： 读取 $ A $：每块 $ 4K $，块数 $ \\frac{M}{4}\\times\\frac{N}{4} $，合计 $ \\frac{M N K}{4} $。 读取 $ B $：每块 $ 4K $，同上合计 $ \\frac{M N K}{4} $。 写入 $ C $：每块 $ 16 $ 次，共 $ M $。 合计：$ 0.5\\, M N K + M N $。 与 $ 1 \\times 4 $ 相比，$ B $ 的读取也减少了 $ 4 \\times $（同一批 $ B[k, j..j+3] $ 复用到 4 行），因此总体内存访问显著下降。\n加速比： $$ S_{\\text{4x4}} \\approx \\frac{4 M N K + M N}{0.5 M N K + M N} \\approx \\frac{4}{0.5} = 8 \\quad (K \\gg 1) $$\nSIMD Vectorization 现在我们引入 SIMD，以 Intel SSE 指令集为例（128-bit，单精度宽度 $ W = 4 $）。下面给出与 AddDot4x4 对齐的简化向量化微内核。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include inline void AddDot4x4_SSE(int K, const float* Aij, const float* Bkj, float* Cij, int N, int Kstride) { __m128 c0 = _mm_setzero_ps(); __m128 c1 = _mm_setzero_ps(); __m128 c2 = _mm_setzero_ps(); __m128 c3 = _mm_setzero_ps(); const float* a0 = Aij + 0 * Kstride; const float* a1 = Aij + 1 * Kstride; const float* a2 = Aij + 2 * Kstride; const float* a3 = Aij + 3 * Kstride; for (int k = 0; k \u003c K; ++k) { __m128 b = _mm_loadu_ps(\u0026Bkj[k * N]); // B[k][j..j+3] __m128 a0v = _mm_set1_ps(a0[k]); __m128 a1v = _mm_set1_ps(a1[k]); __m128 a2v = _mm_set1_ps(a2[k]); __m128 a3v = _mm_set1_ps(a3[k]); c0 = _mm_add_ps(c0, _mm_mul_ps(a0v, b)); c1 = _mm_add_ps(c1, _mm_mul_ps(a1v, b)); c2 = _mm_add_ps(c2, _mm_mul_ps(a2v, b)); c3 = _mm_add_ps(c3, _mm_mul_ps(a3v, b)); } _mm_storeu_ps(\u0026Cij[0 * N], c0); _mm_storeu_ps(\u0026Cij[1 * N], c1); _mm_storeu_ps(\u0026Cij[2 * N], c2); _mm_storeu_ps(\u0026Cij[3 * N], c3); } 分析：\nFLOPs：仍为 $ 2 M N K $。 内存访问：与标量 4×4 相同（$ 0.5\\, M N K + M N $）。SIMD 仅改变算术吞吐，不改变 DRAM 访存量。 计算主导场景的理论加速：约等于向量宽度 $ W $（SSE 单精度为 $ 4 $；AVX2 为 $ 8 $；AVX-512 为 $ 16 $）。若支持 FMA（如 AVX2/FMA、AVX-512），每周期可进一步提升。 加速比：\n内存主导：约 $ 8 \\times $（同 4×4）。 计算主导： 4×4 与 SIMD 的收益不可直接相乘，约 $ 8 \\times W $ 的上界不成立；更实际的估计是：在 4×4 将算术强度显著提升后，若仍处于计算主导，则 SIMD 可再带来 $ W \\times $ 左右的额外提升。 Cache Blocking（Macro-kernel） 尽管 SIMD 和寄存器分块（微内核）带来了巨大的性能提升，但当矩阵尺寸超出 CPU 缓存容量时，性能仍会因高昂的内存访问延迟而下降。缓存分块 (Cache Blocking) 旨在将矩阵操作分解成一系列小块操作，使这些块的数据能够长时间驻留在不同级别的缓存中（例如 L1、L2、L3），从而实现数据重用最大化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 缓存分块 + 4x4 微内核 void gemm_blocked_4x4(int M, int N, int K, const float* A, const float* B, float* C) { const int MR = 4, NR = 4; const int KC = 128; // 需按架构调优 for (int kk = 0; kk \u003c K; kk += KC) { int Kc = std::min(KC, K - kk); for (int i = 0; i \u003c M; i += MR) { int Mb = std::min(MR, M - i); for (int j = 0; j \u003c N; j += NR) { int Nb = std::min(NR, N - j); if (Mb == MR \u0026\u0026 Nb == NR) { AddDot4x4(Kc, \u0026A[i * K + kk], \u0026B[kk * N + j], \u0026C[i * N + j], N, K); } else { // 退化处理 for (int ii = 0; ii \u003c Mb; ++ii) for (int jj = 0; jj \u003c Nb; ++jj) { float acc = 0.f; for (int k = 0; k \u003c Kc; ++k) acc += A[(i + ii) * K + (kk + k)] * B[(kk + k) * N + (j + jj)]; C[(i + ii) * N + (j + jj)] = acc + C[(i + ii) * N + (j + jj)]; } } } } } } 分析：\nFLOPs：仍为 $ 2 M N K $。 DRAM 级内存访问：（理想分块并有良好复用时） $ A $：每个元素从 DRAM 读入约 $ 1 $ 次，$ M K $。 $ B $：每个元素从 DRAM 读入约 $ 1 $ 次，$ K N $。 $ C $：每个元素从 DRAM 读写各 $ 1 $ 次，$ 2 M N $。 合计：$ M K + K N + 2 M N $。 通过按 $ K $ 维度切块，$ A $ 与 $ B $ 的面板在较小的 $ K_c $ 上反复被微内核复用；只要 $ K_c $、$ M_r $、$ N_r $ 选取得当，就能使复用主要发生在 L1/L2/L3 中，从 DRAM 的视角看，$ A $/$ B $ 基本只需读取一次。\n加速比： $$ S_{\\text{blocked}} \\approx \\frac{4 M N K + M N}{M K + K N + 2 M N} $$\n当 $ M = N = K = n $ 时，有 $ S \\approx \\frac{4 n^3}{4 n^2} = n $，随问题规模线性增长，实际受缓存与带宽上限限制。\nData Packing 即使有了缓存分块，如果原始矩阵的内存布局导致块内部的数据不连续（例如，行主序矩阵中的列访问），缓存效率仍然会受损。数据打包 (Packing) 通过将需要计算的矩阵块复制到临时的、内存连续且对齐的缓冲区中来解决这个问题。\n将 $ A $ 的 $ M_r \\times K_c $ 面板按“列优先、行紧凑”的形式打包，便于微内核顺序读取。 将 $ B $ 的 $ K_c \\times N_r $ 面板按“行优先、列紧凑”的形式打包，使得每个 $ k $ 的 $ B[k, j..j+N_r-1] $ 连续、对齐。 示例打包代码（以 $ M_r=4, N_r=4 $ 为例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // pack A: 从行主序 A 中取 4xKc，按列（k）主序、行（r）紧凑存放：Apack[k*4 + r] void pack_A_4xKc(const float* A, int lda, float* Apack, int Kc) { for (int k = 0; k \u003c Kc; ++k) { Apack[k * 4 + 0] = A[0 * lda + k]; Apack[k * 4 + 1] = A[1 * lda + k]; Apack[k * 4 + 2] = A[2 * lda + k]; Apack[k * 4 + 3] = A[3 * lda + k]; } } // pack B: 从行主序 B 中取 Kc x 4，按行（k）主序、列（c）紧凑存放：Bpack[k*4 + c] void pack_B_Kc4(const float* B, int ldb, float* Bpack, int Kc) { for (int k = 0; k \u003c Kc; ++k) { const float* bk = B + k * ldb; Bpack[k * 4 + 0] = bk[0]; Bpack[k * 4 + 1] = bk[1]; Bpack[k * 4 + 2] = bk[2]; Bpack[k * 4 + 3] = bk[3]; } } 配合打包的 4×4 微内核（内层线性访问）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 inline void AddDot4x4_packed(int Kc, const float* Ap, const float* Bp, float* Cij, int N) { __m128 c0 = _mm_setzero_ps(); __m128 c1 = _mm_setzero_ps(); __m128 c2 = _mm_setzero_ps(); __m128 c3 = _mm_setzero_ps(); for (int k = 0; k \u003c Kc; ++k) { __m128 b = _mm_loadu_ps(\u0026Bp[k * 4]); float a0 = Ap[k * 4 + 0]; float a1 = Ap[k * 4 + 1]; float a2 = Ap[k * 4 + 2]; float a3 = Ap[k * 4 + 3]; c0 = _mm_add_ps(c0, _mm_mul_ps(_mm_set1_ps(a0), b)); c1 = _mm_add_ps(c1, _mm_mul_ps(_mm_set1_ps(a1), b)); c2 = _mm_add_ps(c2, _mm_mul_ps(_mm_set1_ps(a2), b)); c3 = _mm_add_ps(c3, _mm_mul_ps(_mm_set1_ps(a3), b)); } _mm_storeu_ps(\u0026Cij[0 * N], _mm_add_ps(c0, _mm_loadu_ps(\u0026Cij[0 * N]))); _mm_storeu_ps(\u0026Cij[1 * N], _mm_add_ps(c1, _mm_loadu_ps(\u0026Cij[1 * N]))); _mm_storeu_ps(\u0026Cij[2 * N], _mm_add_ps(c2, _mm_loadu_ps(\u0026Cij[2 * N]))); _mm_storeu_ps(\u0026Cij[3 * N], _mm_add_ps(c3, _mm_loadu_ps(\u0026Cij[3 * N]))); } FLOPs：不变。 DRAM 访存：与“理想分块”一致（$ M K + K N + 2 M N $），但常数项更小（线性、对齐、可预取），SIMD 装载更高效。 OpenMP Parallelization 在多核 CPU 上，使用 OpenMP 对外层块循环并行是提升性能的有效手段。推荐在线程之间划分 $ (i, j) $ 的宏块，避免对同一 $ C $ 子块的写冲突。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // OpenMP 并行的分块 GEMM（以 4x4 微内核 + K 分块为例） void gemm_blocked_omp(int M, int N, int K, const float* A, const float* B, float* C, int num_threads) { const int MR = 4, NR = 4, KC = 256, MC = 256, NC = 256; #pragma omp parallel num_threads(num_threads) { // 线程私有的临时打包缓冲区 std::vector\u003cfloat\u003e Ap(MR * KC), Bp(KC * NR); #pragma omp for collapse(2) schedule(static) for (int jc = 0; jc \u003c N; jc += NC) { for (int ic = 0; ic \u003c M; ic += MC) { int Nc = std::min(NC, N - jc); int Mc = std::min(MC, M - ic); for (int pc = 0; pc \u003c K; pc += KC) { int Kc = std::min(KC, K - pc); for (int i = ic; i \u003c ic + Mc; i += MR) { int Mb = std::min(MR, ic + Mc - i); for (int j = jc; j \u003c jc + Nc; j += NR) { int Nb = std::min(NR, jc + Nc - j); if (Mb == MR \u0026\u0026 Nb == NR) { pack_A_4xKc(\u0026A[i * K + pc], K, Ap.data(), Kc); pack_B_Kc4(\u0026B[pc * N + j], N, Bp.data(), Kc); AddDot4x4_packed(Kc, Ap.data(), Bp.data(), \u0026C[i * N + j], N); } else { for (int ii = 0; ii \u003c Mb; ++ii) for (int jj = 0; jj \u003c Nb; ++jj) { float acc = 0.f; for (int k = 0; k \u003c Kc; ++k) acc += A[(i + ii) * K + (pc + k)] * B[(pc + k) * N + (j + jj)]; C[(i + ii) * N + (j + jj)] += acc; } } } } } } } } } 分析：\nFLOPs：不变。 DRAM 访存：与“分块 + 打包”的单线程相同（$ M K + K N + 2 M N $）。 加速上界： 计算主导：理想线性加速 $ \\leq T $（线程数）。 内存主导：受内存带宽限制，$ \\leq \\frac{\\text{BW}_{\\text{并行}}}{\\text{BW}_{\\text{单线程}}} $。当达到带宽饱和后继续加线程收益有限。 加速比：\n在“分块 + 打包”基础上，OpenMP 将计算并行化。理想上界（计算主导）：$$ S_{\\text{blocked+packed+OMP}} \\approx \\min\\left(T,\\ \\frac{\\text{PeakFLOPs}}{\\text{单线程 FLOPs}}\\right) \\times \\frac{4 M N K + M N}{M K + K N + 2 M N} $$ 在带宽主导时，上式中 $ T $ 替换为带宽扩展比。 Method Comparison 为便于对比，下面给出各优化策略在“忽略缓存命中、以元素访问计”的内存访问与内存主导模型下的理论加速比（相对 naive）：\n方法 微内核形状 FLOPs 内存访问（元素数） 相对 naive 加速比（内存主导，$ K \\gg 1 $） naive 无 $ 2MNK $ $ 4MNK + MN $ $ 1.0 $ 1×4 寄存器分块 1×4 $ 2MNK $ $ 1.25MNK + MN $ $ \\approx 3.2 $ 1×4 + 展开 1×4 $ 2MNK $ $ 1.25MNK + MN $ $ \\approx 3.2 $（计算主导再 +5%~15%） 4×4 寄存器分块 4×4 $ 2MNK $ $ 0.5MNK + MN $ $ \\approx 8.0 $ 4×4 + SIMD（SSE） 4×4 $ 2MNK $ $ 0.5MNK + MN $ 内存主导 $ \\approx 8.0 $；计算主导再 $ \\times 4 $ 分块（$ K_{c} $）+ 打包 任意 $ 2MNK $ $ MK + KN + 2MN $ $ \\frac{4MNK+MN}{MK+KN+2MN} $（方阵约为 $ n $） 分块 + 打包 +OpenMP 任意 $ 2MNK $ $ MK + KN + 2MN $ 上式 × 并行效率（受带宽与可伸缩性限制） 上表的内存访问为“理想化、从 DRAM 角度”的估算，实际性能取决于缓存命中、预取、对齐、访存指令融合和前端/后端瓶颈等。\n采用 += 写回将引入对 $ C $ 的读操作；若事先知道目标 $ C $ 块为零，可进一步减少读流量。\nComparing with BLAS Libraries 现代 BLAS（如 Intel MKL、OpenBLAS、BLIS）普遍采用“三级分块 + 数据打包 + 专用微内核（含 SIMD/FMA）”的体系： 最外层：$ N_c $、$ M_c $、$ K_c $ 级别的宏分块，匹配 L3/L2。 中层：面板打包（AB-panel），顺序、对齐、预取友好。 内层：手写/内联汇编微内核，固定 $ M_r \\times N_r $，深度展开，寄存器阻塞，利用 FMA 与流水线。 对 x86： SSE 场景常见微内核大小约 $ 4 \\times 4 $。 AVX2/AVX-512 场景常见 $ M_r, N_r $ 更大（如 $ 6 \\times 16 $、$ 8 \\times 30 $ 等），并利用 FMA。 这些库还会进行： 多级预取策略（硬件/软件结合）。 NUMA 感知的任务分配与内存归属（first-touch）。 针对边界块的专门路径和对齐优化。 Summary 从“寄存器分块（微内核）→ SIMD → 缓存分块（宏内核）→ 数据打包 → OpenMP 并行”的路径逐层优化了 GEMM 性能。\n核心思想：\n用寄存器保存部分和，显著减少对 $ C $ 的读写。 通过 $ 1 \\times 4 \\to 4 \\times 4 $ 提高 $ A $/$ B $ 的复用，降低 DRAM 访存。 用 SIMD/FMA 提高每条指令的 FLOPs。 宏分块与打包让复用在 L1/L2/L3 内生效，将 DRAM 流量降到 $ MK + KN + 2MN $ 的量级。 OpenMP 在多核扩展吞吐，但需注意带宽瓶颈与 NUMA。 在内存主导模型下的理论加速（相对 naive）：\n$ 1 \\times 4 $：约 $ 3.2 \\times $。 $ 4 \\times 4 $：约 $ 8 \\times $。 分块 + 打包：约 $ \\frac{4MNK+MN}{MK+KN+2MN} $（方阵近似 $ n $）。 SIMD 与 OpenMP 的收益叠加取决于是否进入计算主导。 References How to optimize GEMM（FLAME wiki） 通用矩阵乘（GEMM）优化算法 OpenBLAS ","wordCount":"3083","inLanguage":"en","image":"https://diefish1024.github.io/images/avatar.jpg","datePublished":"2025-09-12T10:43:00+08:00","dateModified":"2025-09-12T10:43:00+08:00","author":{"@type":"Person","name":"diefish"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diefish1024.github.io/posts/hpc/gemm-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"},"publisher":{"@type":"Organization","name":"diefish's blog","logo":{"@type":"ImageObject","url":"https://diefish1024.github.io/images/avatar.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diefish1024.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://diefish1024.github.io/images/avatar.jpg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diefish1024.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://diefish1024.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://diefish1024.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://diefish1024.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://diefish1024.github.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://diefish1024.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://diefish1024.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://diefish1024.github.io/posts/hpc/>HPC</a></div><h1 class="post-title entry-hint-parent">GEMM 算法优化</h1><div class=post-meta><span title='2025-09-12 10:43:00 +0800 +0800'>September 12, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;diefish&nbsp;|&nbsp;<a href=https://github.com/diefish1024/diefish1024.github.io/blob/main/content/posts/HPC/gemm-%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#naive-gemm aria-label="Naive GEMM">Naive GEMM</a><ul><li><a href=#why-slow aria-label="Why Slow?">Why Slow?</a></li></ul></li><li><a href=#1--4-register-blocking aria-label="1 × 4 Register Blocking">1 × 4 Register Blocking</a></li><li><a href=#loop-unrolling-and-pointer-optimization aria-label="Loop Unrolling and Pointer Optimization">Loop Unrolling and Pointer Optimization</a></li><li><a href=#4--4-register-blocking aria-label="4 × 4 Register Blocking">4 × 4 Register Blocking</a></li><li><a href=#simd-vectorization aria-label="SIMD Vectorization">SIMD Vectorization</a></li><li><a href=#cache-blockingmacro-kernel aria-label="Cache Blocking（Macro-kernel）">Cache Blocking（Macro-kernel）</a></li><li><a href=#data-packing aria-label="Data Packing">Data Packing</a></li><li><a href=#openmp-parallelization aria-label="OpenMP Parallelization">OpenMP Parallelization</a></li><li><a href=#method-comparison aria-label="Method Comparison">Method Comparison</a></li><li><a href=#comparing-with-blas-libraries aria-label="Comparing with BLAS Libraries">Comparing with BLAS Libraries</a></li><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>本文简要介绍通用矩阵乘（<a href=https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms#Level_3>GEMM</a>，General Matrix Multiplication）优化的基本概念和方法。GEMM 是 HPC 领域中最基础且计算密集型的工作负载之一。在人工智能、科学模拟和图像处理等领域，它的性能直接影响着整个应用程序的效率。虽然其数学概念简单，但高效的 GEMM 实现却需要对计算机体系结构有深刻的理解，包括缓存、SIMD 指令集和并行化技术。</p><h2 id=naive-gemm>Naive GEMM<a hidden class=anchor aria-hidden=true href=#naive-gemm>#</a></h2><p>GEMM 通常定义为 $ C = A \times B $，对于矩阵 $ A \in \mathbb{R}^{M \times K} $，矩阵 $ B \in \mathbb{R}^{K \times N} $，其乘积矩阵 $ C\in \mathbb{R}^{M \times N} $ 可以表示为
$$
C_{i,j} = \sum_{k=0}^{K-1} A_{i,k}\times B_{k,j}
$$
对应的朴素代码通常如下（默认行主序存储）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>gemm_naive</span><span class=p>(</span><span class=kt>int</span> <span class=n>M</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>A</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>C</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>M</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mf>0.0f</span><span class=p>;</span> <span class=c1>// 初始化 C[i][j]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>M</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>*</span> <span class=n>B</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ul><li><p><strong>浮点运算总数（FLOPs）</strong>：</p><ul><li>对于每个 $ C_{i,j} $ 元素，需要执行 $ K $ 次乘法和 $ K $ 次加法。</li><li>总共有 $ M \times N $ 个 $ C_{i,j} $ 元素。</li><li>总操作数约为 $ 2 \times M \times N \times K $ 次浮点运算。</li></ul></li><li><p><strong>内存访问总数</strong>：忽略循环变量和指令的开销。</p><ul><li>矩阵 $ C $ 的初始化需要 $ M \times N $ 次写入；循环中矩阵 $ A $ 和矩阵 $ B $ 分别被读取 $ M \times N \times K $ 次，矩阵 $ C $ 被读取和写入共 $ 2 \times M \times N \times K $ 次。</li><li>总内存访问次数约为 $ 4 M N K + M N $。</li></ul></li></ul><h3 id=why-slow>Why Slow?<a hidden class=anchor aria-hidden=true href=#why-slow>#</a></h3><p>尽管代码简洁，但这种实现方式存在严重的性能瓶颈：</p><ul><li><p><strong>缓存利用率低</strong>：对 <code>B[k][j</code> 的访问大概率导致<strong>缓存未命中</strong>。由于 <code>B</code> 是行主序存储，每次迭代 <code>k</code> 都会跳到 <code>B</code> 矩阵的下一行，这导致巨大的内存跨越，破坏了空间局部性。</p></li><li><p><strong>缺乏 SIMD 向量化潜力</strong>：编译器很难将这种混合访问模式有效向量化，因为对 $ B $ 的访问模式不佳。</p></li><li><p>算法本身时间复杂度为 $ O(N^{3}) $。</p></li></ul><p>对这样的矩阵乘的算法优化可分为两类：</p><ul><li>基于算法分析的方法：根据矩阵乘计算特性，从数学角度优化，典型的算法包括 <a href=https://en.wikipedia.org/wiki/Strassen_algorithm title="Strassen 算法">Strassen 算法</a> 和 <a href=https://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm title="Coppersmith–Winograd 算法">Coppersmith–Winograd 算法</a>。</li><li>基于软件优化的方法：根据计算机存储系统的层次结构特性，选择性地调整计算顺序，主要有循环拆分向量化、内存重排等。</li></ul><p>数学角度的优化暂且不在本文的讨论范围内，有机会将单独介绍，下面给出计算机体系结构角度的一些优化角度。</p><h2 id=1--4-register-blocking><code>1 × 4</code> Register Blocking<a hidden class=anchor aria-hidden=true href=#1--4-register-blocking>#</a></h2><p>参考 <a href=https://github.com/flame/how-to-optimize-gemm/wiki>how to optimize gemm</a> 一文，我们把输出的计算按照列拆分成若干个 $ 1 \times 4 $ 的小块，通过一次性处理 $ C $ 的一小块内存来减少内存操作，最大化寄存器的利用率。</p><p>与其一次计算 $ C_{i,j} $ 一个元素，不如一次性计算 $ C_{i, j\sim j+3} $ 四个连续元素，这很好地利用了 $ C $ 矩阵行内的空间局部性。把这四个元素加载到寄存器，可以大大减少对主存的访问次数。</p><p><img loading=lazy src=/images/gemm-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/pasted-image-20250914111750-png></p><blockquote><p>下文我们将最内层的循环称为<strong>微内核（micro kernel）</strong>，比如 <code>AddDot1x4</code> 就是一个微内核。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// AddDot1x4: 计算 C 的一个 1x4 块（按行主序）
</span></span></span><span class=line><span class=cl><span class=c1>// Ai 指向 A 的第 i 行起始；Bj 指向 B 的第 j 列所在的起始位置；Cij 指向 C[i][j]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>AddDot1x4</span><span class=p>(</span><span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Ai</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Bj</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Cij</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>c0</span> <span class=o>=</span> <span class=mf>0.0f</span><span class=p>,</span> <span class=n>c1</span> <span class=o>=</span> <span class=mf>0.0f</span><span class=p>,</span> <span class=n>c2</span> <span class=o>=</span> <span class=mf>0.0f</span><span class=p>,</span> <span class=n>c3</span> <span class=o>=</span> <span class=mf>0.0f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Ai</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>bk</span> <span class=o>=</span> <span class=n>Bj</span> <span class=o>+</span> <span class=n>k</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span> <span class=c1>// B[k][j..j+3]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>c0</span> <span class=o>+=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>c1</span> <span class=o>+=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span> <span class=o>+=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>c3</span> <span class=o>+=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>c0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>c1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>c2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>c3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>gemm_1x4_blocked</span><span class=p>(</span><span class=kt>int</span> <span class=n>M</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>A</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>C</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>M</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Ai</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>K</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>j</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>w</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=n>N</span> <span class=o>-</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>w</span> <span class=o>==</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>AddDot1x4</span><span class=p>(</span><span class=n>K</span><span class=p>,</span> <span class=n>Ai</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>C</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=n>j</span><span class=p>],</span> <span class=n>N</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// 处理尾部 &lt;4 列
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>jj</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>jj</span> <span class=o>&lt;</span> <span class=n>w</span><span class=p>;</span> <span class=o>++</span><span class=n>jj</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=kt>float</span> <span class=n>acc</span> <span class=o>=</span> <span class=mf>0.f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=n>acc</span> <span class=o>+=</span> <span class=n>Ai</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>*</span> <span class=n>B</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=n>jj</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>                    <span class=n>C</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=n>j</span> <span class=o>+</span> <span class=n>jj</span><span class=p>]</span> <span class=o>=</span> <span class=n>acc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ul><li><strong>FLOPs</strong>：仍为 $ 2 M N K $。</li><li><strong>内存访问</strong>：（以元素计，忽略缓存命中）<ul><li>读取 $ A $：对每个 $ 1 \times 4 $ 块，每次 $ K $ 次，共 $ \frac{M N}{4} \times K = \frac{M N K}{4} $。</li><li>读取 $ B $：每次 $ 4K $，共 $ \frac{M N}{4} \times 4K = M N K $。</li><li>写入 $ C $：每块写 $ 4 $ 次，共 $ M N $。无需读取 $ C $（寄存器累加后赋值）。</li></ul></li><li><strong>合计</strong>：$ \frac{1}{4} M N K + 1 \cdot M N K + M N = 1.25\, M N K + M N $。</li></ul><blockquote><p>与 naive 相比，$ A $ 的读取减少了 $ 4 \times $（复用到 4 个连续列），$ B $ 的读取次数相同但连续访问更友好，$ C $ 的访存从每次迭代读写降为仅写一次。</p></blockquote><p><strong>加速比</strong>：</p><p>在内存带宽主导的 <a href=https://en.wikipedia.org/wiki/Roofline_model>Roofline 模型</a> 下，性能与内存访问次数近似成反比，因此加速比为
$$
S_{\text{1x4}} \approx \frac{4 M N K + M N}{1.25 M N K + M N} \approx \frac{4}{1.25} = 3.2 \quad (K \gg 1)
$$</p><h2 id=loop-unrolling-and-pointer-optimization>Loop Unrolling and Pointer Optimization<a hidden class=anchor aria-hidden=true href=#loop-unrolling-and-pointer-optimization>#</a></h2><p>为了进一步优化，我们在 <code>AddDot1x4</code> 内部使用指针迭代与循环展开，减少地址计算和分支开销，提升指令级并行性与寄存器利用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>AddDot1x4_unroll4</span><span class=p>(</span><span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Ai</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Bj</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Cij</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>c0</span> <span class=o>=</span> <span class=mf>0.f</span><span class=p>,</span> <span class=n>c1</span> <span class=o>=</span> <span class=mf>0.f</span><span class=p>,</span> <span class=n>c2</span> <span class=o>=</span> <span class=mf>0.f</span><span class=p>,</span> <span class=n>c3</span> <span class=o>=</span> <span class=mf>0.f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Ai</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=n>Bj</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>k</span> <span class=o>+</span> <span class=mi>3</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>a0</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>a1</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>a3</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>b0</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=mi>0</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>b1</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>b2</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>b3</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>c0</span> <span class=o>+=</span> <span class=n>a0</span> <span class=o>*</span> <span class=n>b0</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>a1</span> <span class=o>*</span> <span class=n>b1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>a2</span> <span class=o>*</span> <span class=n>b2</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>a3</span> <span class=o>*</span> <span class=n>b3</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>c1</span> <span class=o>+=</span> <span class=n>a0</span> <span class=o>*</span> <span class=n>b0</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>a1</span> <span class=o>*</span> <span class=n>b1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>a2</span> <span class=o>*</span> <span class=n>b2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>a3</span> <span class=o>*</span> <span class=n>b3</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span> <span class=o>+=</span> <span class=n>a0</span> <span class=o>*</span> <span class=n>b0</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>a1</span> <span class=o>*</span> <span class=n>b1</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>a2</span> <span class=o>*</span> <span class=n>b2</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>a3</span> <span class=o>*</span> <span class=n>b3</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>c3</span> <span class=o>+=</span> <span class=n>a0</span> <span class=o>*</span> <span class=n>b0</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>+</span> <span class=n>a1</span> <span class=o>*</span> <span class=n>b1</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>+</span> <span class=n>a2</span> <span class=o>*</span> <span class=n>b2</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>+</span> <span class=n>a3</span> <span class=o>*</span> <span class=n>b3</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>+=</span> <span class=mi>4</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>av</span> <span class=o>=</span> <span class=o>*</span><span class=n>a</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>bk</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span> <span class=n>b</span> <span class=o>+=</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>c0</span> <span class=o>+=</span> <span class=n>av</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=n>c1</span> <span class=o>+=</span> <span class=n>av</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span> <span class=n>c2</span> <span class=o>+=</span> <span class=n>av</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span> <span class=n>c3</span> <span class=o>+=</span> <span class=n>av</span> <span class=o>*</span> <span class=n>bk</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>c0</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>c1</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>c2</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>c3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ul><li><strong>FLOPs</strong>：仍为 $ 2 M N K $。</li><li><strong>内存访问</strong>：与 $ 1 \times 4 $ 相同（$ 1.25\, M N K + M N $），仅减少了地址计算和分支开销。</li></ul><p><strong>加速比</strong>：</p><ul><li><strong>内存主导</strong>：与 $ 1 \times 4 $ 相同，约 $ 3.2 \times $。</li><li><strong>计算主导</strong>：循环展开可进一步减少指令开销，常见提升在 $ 5\% \sim 15\% $ 范围（与编译器和微架构相关）。</li></ul><h2 id=4--4-register-blocking><code>4 × 4</code> Register Blocking<a hidden class=anchor aria-hidden=true href=#4--4-register-blocking>#</a></h2><p>不难意识到，用一样的逻辑可以把上面的寄存器分块从 $ 1 \times 4 $ 扩展到 $ 4 \times 4 $。这样可以进一步减少内存操作，提高效率。</p><p><img loading=lazy src=/images/gemm-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/pasted-image-20250914113809-png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// AddDot4x4: 计算 C 的一个 4x4 块（行主序，传入 C 的起始为 C[i][j]）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>AddDot4x4</span><span class=p>(</span><span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Aij</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Bkj</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Cij</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Kstride</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span>
</span></span><span class=line><span class=cl>        <span class=n>c00</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c01</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c02</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c03</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>c10</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c11</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c12</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c13</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>c20</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c21</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c22</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c23</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>c30</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c31</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c32</span><span class=o>=</span><span class=mf>0.f</span><span class=p>,</span><span class=n>c33</span><span class=o>=</span><span class=mf>0.f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a0</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>0</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a1</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a3</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>a0k</span> <span class=o>=</span> <span class=n>a0</span><span class=p>[</span><span class=n>k</span><span class=p>],</span> <span class=n>a1k</span> <span class=o>=</span> <span class=n>a1</span><span class=p>[</span><span class=n>k</span><span class=p>],</span> <span class=n>a2k</span> <span class=o>=</span> <span class=n>a2</span><span class=p>[</span><span class=n>k</span><span class=p>],</span> <span class=n>a3k</span> <span class=o>=</span> <span class=n>a3</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>bk</span> <span class=o>=</span> <span class=n>Bkj</span> <span class=o>+</span> <span class=n>k</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>b0</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>b1</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>b2</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>b3</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>c00</span> <span class=o>+=</span> <span class=n>a0k</span> <span class=o>*</span> <span class=n>b0</span><span class=p>;</span> <span class=n>c01</span> <span class=o>+=</span> <span class=n>a0k</span> <span class=o>*</span> <span class=n>b1</span><span class=p>;</span> <span class=n>c02</span> <span class=o>+=</span> <span class=n>a0k</span> <span class=o>*</span> <span class=n>b2</span><span class=p>;</span> <span class=n>c03</span> <span class=o>+=</span> <span class=n>a0k</span> <span class=o>*</span> <span class=n>b3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>c10</span> <span class=o>+=</span> <span class=n>a1k</span> <span class=o>*</span> <span class=n>b0</span><span class=p>;</span> <span class=n>c11</span> <span class=o>+=</span> <span class=n>a1k</span> <span class=o>*</span> <span class=n>b1</span><span class=p>;</span> <span class=n>c12</span> <span class=o>+=</span> <span class=n>a1k</span> <span class=o>*</span> <span class=n>b2</span><span class=p>;</span> <span class=n>c13</span> <span class=o>+=</span> <span class=n>a1k</span> <span class=o>*</span> <span class=n>b3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>c20</span> <span class=o>+=</span> <span class=n>a2k</span> <span class=o>*</span> <span class=n>b0</span><span class=p>;</span> <span class=n>c21</span> <span class=o>+=</span> <span class=n>a2k</span> <span class=o>*</span> <span class=n>b1</span><span class=p>;</span> <span class=n>c22</span> <span class=o>+=</span> <span class=n>a2k</span> <span class=o>*</span> <span class=n>b2</span><span class=p>;</span> <span class=n>c23</span> <span class=o>+=</span> <span class=n>a2k</span> <span class=o>*</span> <span class=n>b3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>c30</span> <span class=o>+=</span> <span class=n>a3k</span> <span class=o>*</span> <span class=n>b0</span><span class=p>;</span> <span class=n>c31</span> <span class=o>+=</span> <span class=n>a3k</span> <span class=o>*</span> <span class=n>b1</span><span class=p>;</span> <span class=n>c32</span> <span class=o>+=</span> <span class=n>a3k</span> <span class=o>*</span> <span class=n>b2</span><span class=p>;</span> <span class=n>c33</span> <span class=o>+=</span> <span class=n>a3k</span> <span class=o>*</span> <span class=n>b3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>0</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=n>c00</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>0</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>c01</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>0</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>=</span><span class=n>c02</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>0</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>3</span><span class=p>]</span><span class=o>=</span><span class=n>c03</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>1</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=n>c10</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>1</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>c11</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>1</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>=</span><span class=n>c12</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>1</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>3</span><span class=p>]</span><span class=o>=</span><span class=n>c13</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=n>c20</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>c21</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>=</span><span class=n>c22</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>3</span><span class=p>]</span><span class=o>=</span><span class=n>c23</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Cij</span><span class=p>[</span><span class=mi>3</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=n>c30</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>3</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>c31</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>3</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>=</span><span class=n>c32</span><span class=p>;</span> <span class=n>Cij</span><span class=p>[</span><span class=mi>3</span><span class=o>*</span><span class=n>N</span><span class=o>+</span><span class=mi>3</span><span class=p>]</span><span class=o>=</span><span class=n>c33</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ul><li>FLOPs：仍为 $ 2 M N K $。</li><li>内存访问（元素计）：<ul><li>读取 $ A $：每块 $ 4K $，块数 $ \frac{M}{4}\times\frac{N}{4} $，合计 $ \frac{M N K}{4} $。</li><li>读取 $ B $：每块 $ 4K $，同上合计 $ \frac{M N K}{4} $。</li><li>写入 $ C $：每块 $ 16 $ 次，共 $ M $。</li></ul></li><li>合计：$ 0.5\, M N K + M N $。</li></ul><blockquote><p>与 $ 1 \times 4 $ 相比，$ B $ 的读取也减少了 $ 4 \times $（同一批 $ B[k, j..j+3] $ 复用到 4 行），因此总体内存访问显著下降。</p></blockquote><p><strong>加速比</strong>：
$$
S_{\text{4x4}} \approx \frac{4 M N K + M N}{0.5 M N K + M N} \approx \frac{4}{0.5} = 8 \quad (K \gg 1)
$$</p><h2 id=simd-vectorization>SIMD Vectorization<a hidden class=anchor aria-hidden=true href=#simd-vectorization>#</a></h2><p>现在我们引入 SIMD，以 Intel SSE 指令集为例（128-bit，单精度宽度 $ W = 4 $）。下面给出与 <code>AddDot4x4</code> 对齐的简化向量化微内核。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;immintrin.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>AddDot4x4_SSE</span><span class=p>(</span><span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Aij</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Bkj</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Cij</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Kstride</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c0</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c1</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c2</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c3</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a0</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>0</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a1</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>a3</span> <span class=o>=</span> <span class=n>Aij</span> <span class=o>+</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>Kstride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>__m128</span> <span class=n>b</span> <span class=o>=</span> <span class=n>_mm_loadu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Bkj</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=n>N</span><span class=p>]);</span> <span class=c1>// B[k][j..j+3]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>__m128</span> <span class=n>a0v</span> <span class=o>=</span> <span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a0</span><span class=p>[</span><span class=n>k</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=kr>__m128</span> <span class=n>a1v</span> <span class=o>=</span> <span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a1</span><span class=p>[</span><span class=n>k</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=kr>__m128</span> <span class=n>a2v</span> <span class=o>=</span> <span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a2</span><span class=p>[</span><span class=n>k</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=kr>__m128</span> <span class=n>a3v</span> <span class=o>=</span> <span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a3</span><span class=p>[</span><span class=n>k</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>c0</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c0</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>a0v</span><span class=p>,</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>c1</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c1</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>a1v</span><span class=p>,</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c2</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>a2v</span><span class=p>,</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>c3</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c3</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>a3v</span><span class=p>,</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>0</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>c0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>1</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>c1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>2</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>c2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>3</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>c3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ul><li><strong>FLOPs</strong>：仍为 $ 2 M N K $。</li><li><strong>内存访问</strong>：与标量 <code>4×4</code> 相同（$ 0.5\, M N K + M N $）。SIMD 仅改变算术吞吐，不改变 DRAM 访存量。</li><li>计算主导场景的理论加速：约等于向量宽度 $ W $（SSE 单精度为 $ 4 $；AVX2 为 $ 8 $；AVX-512 为 $ 16 $）。若支持 FMA（如 AVX2/FMA、AVX-512），每周期可进一步提升。</li></ul><p><strong>加速比</strong>：</p><ul><li><strong>内存主导</strong>：约 $ 8 \times $（同 <code>4×4</code>）。</li><li><strong>计算主导</strong>： <code>4×4</code> 与 SIMD 的收益不可直接相乘，约 $ 8 \times W $ 的上界不成立；更实际的估计是：在 <code>4×4</code> 将算术强度显著提升后，若仍处于计算主导，则 SIMD 可再带来 $ W \times $ 左右的额外提升。</li></ul><h2 id=cache-blockingmacro-kernel>Cache Blocking（Macro-kernel）<a hidden class=anchor aria-hidden=true href=#cache-blockingmacro-kernel>#</a></h2><p>尽管 SIMD 和寄存器分块（微内核）带来了巨大的性能提升，但当矩阵尺寸超出 CPU 缓存容量时，性能仍会因高昂的内存访问延迟而下降。<strong>缓存分块 (Cache Blocking)</strong> 旨在将矩阵操作分解成一系列小块操作，使这些块的数据能够长时间驻留在不同级别的缓存中（例如 L1、L2、L3），从而实现数据重用最大化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 缓存分块 + 4x4 微内核
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>gemm_blocked_4x4</span><span class=p>(</span><span class=kt>int</span> <span class=n>M</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>A</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>C</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MR</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>NR</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>KC</span> <span class=o>=</span> <span class=mi>128</span><span class=p>;</span> <span class=c1>// 需按架构调优
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>kk</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>kk</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=n>kk</span> <span class=o>+=</span> <span class=n>KC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>Kc</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>KC</span><span class=p>,</span> <span class=n>K</span> <span class=o>-</span> <span class=n>kk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>M</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>MR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>Mb</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>MR</span><span class=p>,</span> <span class=n>M</span> <span class=o>-</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>j</span> <span class=o>+=</span> <span class=n>NR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>Nb</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>NR</span><span class=p>,</span> <span class=n>N</span> <span class=o>-</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>Mb</span> <span class=o>==</span> <span class=n>MR</span> <span class=o>&amp;&amp;</span> <span class=n>Nb</span> <span class=o>==</span> <span class=n>NR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>AddDot4x4</span><span class=p>(</span><span class=n>Kc</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>K</span> <span class=o>+</span> <span class=n>kk</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>B</span><span class=p>[</span><span class=n>kk</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=n>j</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>C</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=n>j</span><span class=p>],</span> <span class=n>N</span><span class=p>,</span> <span class=n>K</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// 退化处理
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ii</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ii</span> <span class=o>&lt;</span> <span class=n>Mb</span><span class=p>;</span> <span class=o>++</span><span class=n>ii</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>jj</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>jj</span> <span class=o>&lt;</span> <span class=n>Nb</span><span class=p>;</span> <span class=o>++</span><span class=n>jj</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=kt>float</span> <span class=n>acc</span> <span class=o>=</span> <span class=mf>0.f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>Kc</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=n>acc</span> <span class=o>+=</span> <span class=n>A</span><span class=p>[(</span><span class=n>i</span> <span class=o>+</span> <span class=n>ii</span><span class=p>)</span> <span class=o>*</span> <span class=n>K</span> <span class=o>+</span> <span class=p>(</span><span class=n>kk</span> <span class=o>+</span> <span class=n>k</span><span class=p>)]</span> <span class=o>*</span> <span class=n>B</span><span class=p>[(</span><span class=n>kk</span> <span class=o>+</span> <span class=n>k</span><span class=p>)</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=n>jj</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>                            <span class=n>C</span><span class=p>[(</span><span class=n>i</span> <span class=o>+</span> <span class=n>ii</span><span class=p>)</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=n>jj</span><span class=p>)]</span> <span class=o>=</span> <span class=n>acc</span> <span class=o>+</span> <span class=n>C</span><span class=p>[(</span><span class=n>i</span> <span class=o>+</span> <span class=n>ii</span><span class=p>)</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=n>jj</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ul><li><strong>FLOPs</strong>：仍为 $ 2 M N K $。</li><li><strong>DRAM 级内存访问</strong>：（理想分块并有良好复用时）<ul><li>$ A $：每个元素从 DRAM 读入约 $ 1 $ 次，$ M K $。</li><li>$ B $：每个元素从 DRAM 读入约 $ 1 $ 次，$ K N $。</li><li>$ C $：每个元素从 DRAM 读写各 $ 1 $ 次，$ 2 M N $。</li></ul></li><li>合计：$ M K + K N + 2 M N $。</li></ul><blockquote><p>通过按 $ K $ 维度切块，$ A $ 与 $ B $ 的面板在较小的 $ K_c $ 上反复被微内核复用；只要 $ K_c $、$ M_r $、$ N_r $ 选取得当，就能使复用主要发生在 L1/L2/L3 中，从 DRAM 的视角看，$ A $/$ B $ 基本只需读取一次。</p></blockquote><p><strong>加速比</strong>：
$$
S_{\text{blocked}} \approx \frac{4 M N K + M N}{M K + K N + 2 M N}
$$</p><p>当 $ M = N = K = n $ 时，有 $ S \approx \frac{4 n^3}{4 n^2} = n $，随问题规模线性增长，实际受缓存与带宽上限限制。</p><h2 id=data-packing>Data Packing<a hidden class=anchor aria-hidden=true href=#data-packing>#</a></h2><p>即使有了缓存分块，如果原始矩阵的内存布局导致块内部的数据不连续（例如，行主序矩阵中的列访问），缓存效率仍然会受损。<strong>数据打包 (Packing)</strong> 通过将需要计算的矩阵块复制到临时的、内存<strong>连续且对齐</strong>的缓冲区中来解决这个问题。</p><ul><li>将 $ A $ 的 $ M_r \times K_c $ 面板按“列优先、行紧凑”的形式打包，便于微内核顺序读取。</li><li>将 $ B $ 的 $ K_c \times N_r $ 面板按“行优先、列紧凑”的形式打包，使得每个 $ k $ 的 $ B[k, j..j+N_r-1] $ 连续、对齐。</li></ul><p>示例打包代码（以 $ M_r=4, N_r=4 $ 为例）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// pack A: 从行主序 A 中取 4xKc，按列（k）主序、行（r）紧凑存放：Apack[k*4 + r]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>pack_A_4xKc</span><span class=p>(</span><span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>A</span><span class=p>,</span> <span class=kt>int</span> <span class=n>lda</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Apack</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Kc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>Kc</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Apack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=mi>0</span> <span class=o>*</span> <span class=n>lda</span> <span class=o>+</span> <span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Apack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=mi>1</span> <span class=o>*</span> <span class=n>lda</span> <span class=o>+</span> <span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Apack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=mi>2</span> <span class=o>*</span> <span class=n>lda</span> <span class=o>+</span> <span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Apack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=mi>3</span> <span class=o>*</span> <span class=n>lda</span> <span class=o>+</span> <span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// pack B: 从行主序 B 中取 Kc x 4，按行（k）主序、列（c）紧凑存放：Bpack[k*4 + c]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>pack_B_Kc4</span><span class=p>(</span><span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>B</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ldb</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Bpack</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Kc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>Kc</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>bk</span> <span class=o>=</span> <span class=n>B</span> <span class=o>+</span> <span class=n>k</span> <span class=o>*</span> <span class=n>ldb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Bpack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Bpack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Bpack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Bpack</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>bk</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>配合打包的 4×4 微内核（内层线性访问）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>AddDot4x4_packed</span><span class=p>(</span><span class=kt>int</span> <span class=n>Kc</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Ap</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Bp</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>Cij</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c0</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c1</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c2</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kr>__m128</span> <span class=n>c3</span> <span class=o>=</span> <span class=n>_mm_setzero_ps</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>Kc</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>__m128</span> <span class=n>b</span> <span class=o>=</span> <span class=n>_mm_loadu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Bp</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>a0</span> <span class=o>=</span> <span class=n>Ap</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>a1</span> <span class=o>=</span> <span class=n>Ap</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>Ap</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>a3</span> <span class=o>=</span> <span class=n>Ap</span><span class=p>[</span><span class=n>k</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>c0</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c0</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a0</span><span class=p>),</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>c1</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c1</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a1</span><span class=p>),</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c2</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a2</span><span class=p>),</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>c3</span> <span class=o>=</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c3</span><span class=p>,</span> <span class=n>_mm_mul_ps</span><span class=p>(</span><span class=n>_mm_set1_ps</span><span class=p>(</span><span class=n>a3</span><span class=p>),</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>0</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c0</span><span class=p>,</span> <span class=n>_mm_loadu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>0</span> <span class=o>*</span> <span class=n>N</span><span class=p>])));</span>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>1</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c1</span><span class=p>,</span> <span class=n>_mm_loadu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>1</span> <span class=o>*</span> <span class=n>N</span><span class=p>])));</span>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>2</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c2</span><span class=p>,</span> <span class=n>_mm_loadu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>2</span> <span class=o>*</span> <span class=n>N</span><span class=p>])));</span>
</span></span><span class=line><span class=cl>    <span class=n>_mm_storeu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>3</span> <span class=o>*</span> <span class=n>N</span><span class=p>],</span> <span class=n>_mm_add_ps</span><span class=p>(</span><span class=n>c3</span><span class=p>,</span> <span class=n>_mm_loadu_ps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Cij</span><span class=p>[</span><span class=mi>3</span> <span class=o>*</span> <span class=n>N</span><span class=p>])));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>FLOPs</strong>：不变。</li><li><strong>DRAM 访存</strong>：与“理想分块”一致（$ M K + K N + 2 M N $），但常数项更小（线性、对齐、可预取），SIMD 装载更高效。</li></ul><h2 id=openmp-parallelization>OpenMP Parallelization<a hidden class=anchor aria-hidden=true href=#openmp-parallelization>#</a></h2><p>在多核 CPU 上，使用 OpenMP 对外层块循环并行是提升性能的有效手段。推荐在线程之间划分 $ (i, j) $ 的宏块，避免对同一 $ C $ 子块的写冲突。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// OpenMP 并行的分块 GEMM（以 4x4 微内核 + K 分块为例）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>gemm_blocked_omp</span><span class=p>(</span><span class=kt>int</span> <span class=n>M</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>A</span><span class=p>,</span> <span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>num_threads</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>MR</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>NR</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>KC</span> <span class=o>=</span> <span class=mi>256</span><span class=p>,</span> <span class=n>MC</span> <span class=o>=</span> <span class=mi>256</span><span class=p>,</span> <span class=n>NC</span> <span class=o>=</span> <span class=mi>256</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#pragma omp parallel num_threads(num_threads)
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 线程私有的临时打包缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>Ap</span><span class=p>(</span><span class=n>MR</span> <span class=o>*</span> <span class=n>KC</span><span class=p>),</span> <span class=n>Bp</span><span class=p>(</span><span class=n>KC</span> <span class=o>*</span> <span class=n>NR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cp>#pragma omp for collapse(2) schedule(static)
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>jc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>jc</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>jc</span> <span class=o>+=</span> <span class=n>NC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ic</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ic</span> <span class=o>&lt;</span> <span class=n>M</span><span class=p>;</span> <span class=n>ic</span> <span class=o>+=</span> <span class=n>MC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>Nc</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>NC</span><span class=p>,</span> <span class=n>N</span> <span class=o>-</span> <span class=n>jc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>Mc</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>MC</span><span class=p>,</span> <span class=n>M</span> <span class=o>-</span> <span class=n>ic</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>pc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>pc</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=n>pc</span> <span class=o>+=</span> <span class=n>KC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>Kc</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>KC</span><span class=p>,</span> <span class=n>K</span> <span class=o>-</span> <span class=n>pc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>ic</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ic</span> <span class=o>+</span> <span class=n>Mc</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>MR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=kt>int</span> <span class=n>Mb</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>MR</span><span class=p>,</span> <span class=n>ic</span> <span class=o>+</span> <span class=n>Mc</span> <span class=o>-</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>jc</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>jc</span> <span class=o>+</span> <span class=n>Nc</span><span class=p>;</span> <span class=n>j</span> <span class=o>+=</span> <span class=n>NR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=kt>int</span> <span class=n>Nb</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>NR</span><span class=p>,</span> <span class=n>jc</span> <span class=o>+</span> <span class=n>Nc</span> <span class=o>-</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=k>if</span> <span class=p>(</span><span class=n>Mb</span> <span class=o>==</span> <span class=n>MR</span> <span class=o>&amp;&amp;</span> <span class=n>Nb</span> <span class=o>==</span> <span class=n>NR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=n>pack_A_4xKc</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>K</span> <span class=o>+</span> <span class=n>pc</span><span class=p>],</span> <span class=n>K</span><span class=p>,</span> <span class=n>Ap</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>Kc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                <span class=n>pack_B_Kc4</span><span class=p>(</span><span class=o>&amp;</span><span class=n>B</span><span class=p>[</span><span class=n>pc</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=n>j</span><span class=p>],</span> <span class=n>N</span><span class=p>,</span> <span class=n>Bp</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>Kc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                <span class=n>AddDot4x4_packed</span><span class=p>(</span><span class=n>Kc</span><span class=p>,</span> <span class=n>Ap</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>Bp</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>C</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=n>j</span><span class=p>],</span> <span class=n>N</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ii</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ii</span> <span class=o>&lt;</span> <span class=n>Mb</span><span class=p>;</span> <span class=o>++</span><span class=n>ii</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>jj</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>jj</span> <span class=o>&lt;</span> <span class=n>Nb</span><span class=p>;</span> <span class=o>++</span><span class=n>jj</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                        <span class=kt>float</span> <span class=n>acc</span> <span class=o>=</span> <span class=mf>0.f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>Kc</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                            <span class=n>acc</span> <span class=o>+=</span> <span class=n>A</span><span class=p>[(</span><span class=n>i</span> <span class=o>+</span> <span class=n>ii</span><span class=p>)</span> <span class=o>*</span> <span class=n>K</span> <span class=o>+</span> <span class=p>(</span><span class=n>pc</span> <span class=o>+</span> <span class=n>k</span><span class=p>)]</span> <span class=o>*</span> <span class=n>B</span><span class=p>[(</span><span class=n>pc</span> <span class=o>+</span> <span class=n>k</span><span class=p>)</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=n>jj</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>                                        <span class=n>C</span><span class=p>[(</span><span class=n>i</span> <span class=o>+</span> <span class=n>ii</span><span class=p>)</span> <span class=o>*</span> <span class=n>N</span> <span class=o>+</span> <span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=n>jj</span><span class=p>)]</span> <span class=o>+=</span> <span class=n>acc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ul><li><strong>FLOPs</strong>：不变。</li><li><strong>DRAM 访存</strong>：与“分块 + 打包”的单线程相同（$ M K + K N + 2 M N $）。</li><li><strong>加速上界</strong>：<ul><li>计算主导：理想线性加速 $ \leq T $（线程数）。</li><li>内存主导：受内存带宽限制，$ \leq \frac{\text{BW}_{\text{并行}}}{\text{BW}_{\text{单线程}}} $。当达到带宽饱和后继续加线程收益有限。</li></ul></li></ul><p><strong>加速比</strong>：</p><ul><li>在“分块 + 打包”基础上，OpenMP 将计算并行化。理想上界（计算主导）：$$
S_{\text{blocked+packed+OMP}} \approx \min\left(T,\ \frac{\text{PeakFLOPs}}{\text{单线程 FLOPs}}\right) \times \frac{4 M N K + M N}{M K + K N + 2 M N}
$$</li><li>在带宽主导时，上式中 $ T $ 替换为带宽扩展比。</li></ul><h2 id=method-comparison>Method Comparison<a hidden class=anchor aria-hidden=true href=#method-comparison>#</a></h2><p>为便于对比，下面给出各优化策略在“忽略缓存命中、以元素访问计”的内存访问与内存主导模型下的理论加速比（相对 naive）：</p><table><thead><tr><th>方法</th><th>微内核形状</th><th>FLOPs</th><th>内存访问（元素数）</th><th>相对 naive 加速比（内存主导，$ K \gg 1 $）</th></tr></thead><tbody><tr><td>naive</td><td>无</td><td>$ 2MNK $</td><td>$ 4MNK + MN $</td><td>$ 1.0 $</td></tr><tr><td>1×4 寄存器分块</td><td>1×4</td><td>$ 2MNK $</td><td>$ 1.25MNK + MN $</td><td>$ \approx 3.2 $</td></tr><tr><td>1×4 + 展开</td><td>1×4</td><td>$ 2MNK $</td><td>$ 1.25MNK + MN $</td><td>$ \approx 3.2 $（计算主导再 +5%~15%）</td></tr><tr><td>4×4 寄存器分块</td><td>4×4</td><td>$ 2MNK $</td><td>$ 0.5MNK + MN $</td><td>$ \approx 8.0 $</td></tr><tr><td>4×4 + SIMD（SSE）</td><td>4×4</td><td>$ 2MNK $</td><td>$ 0.5MNK + MN $</td><td>内存主导 $ \approx 8.0 $；计算主导再 $ \times 4 $</td></tr><tr><td>分块（$ K_{c} $）+ 打包</td><td>任意</td><td>$ 2MNK $</td><td>$ MK + KN + 2MN $</td><td>$ \frac{4MNK+MN}{MK+KN+2MN} $（方阵约为 $ n $）</td></tr><tr><td>分块 + 打包 +OpenMP</td><td>任意</td><td>$ 2MNK $</td><td>$ MK + KN + 2MN $</td><td>上式 × 并行效率（受带宽与可伸缩性限制）</td></tr></tbody></table><ul><li><p>上表的内存访问为“理想化、从 DRAM 角度”的估算，实际性能取决于缓存命中、预取、对齐、访存指令融合和前端/后端瓶颈等。</p></li><li><p>采用 <code>+=</code> 写回将引入对 $ C $ 的读操作；若事先知道目标 $ C $ 块为零，可进一步减少读流量。</p></li></ul><h2 id=comparing-with-blas-libraries>Comparing with BLAS Libraries<a hidden class=anchor aria-hidden=true href=#comparing-with-blas-libraries>#</a></h2><ul><li>现代 BLAS（如 Intel MKL、OpenBLAS、BLIS）普遍采用“三级分块 + 数据打包 + 专用微内核（含 SIMD/FMA）”的体系：<ul><li>最外层：$ N_c $、$ M_c $、$ K_c $ 级别的宏分块，匹配 L3/L2。</li><li>中层：面板打包（AB-panel），顺序、对齐、预取友好。</li><li>内层：手写/内联汇编微内核，固定 $ M_r \times N_r $，深度展开，寄存器阻塞，利用 FMA 与流水线。</li></ul></li><li>对 x86：<ul><li>SSE 场景常见微内核大小约 $ 4 \times 4 $。</li><li>AVX2/AVX-512 场景常见 $ M_r, N_r $ 更大（如 $ 6 \times 16 $、$ 8 \times 30 $ 等），并利用 FMA。</li></ul></li><li>这些库还会进行：<ul><li>多级预取策略（硬件/软件结合）。</li><li>NUMA 感知的任务分配与内存归属（first-touch）。</li><li>针对边界块的专门路径和对齐优化。</li></ul></li></ul><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><ul><li><p>从“寄存器分块（微内核）→ SIMD → 缓存分块（宏内核）→ 数据打包 → OpenMP 并行”的路径逐层优化了 GEMM 性能。</p></li><li><p>核心思想：</p><ol><li>用寄存器保存部分和，显著减少对 $ C $ 的读写。</li><li>通过 $ 1 \times 4 \to 4 \times 4 $ 提高 $ A $/$ B $ 的复用，降低 DRAM 访存。</li><li>用 SIMD/FMA 提高每条指令的 FLOPs。</li><li>宏分块与打包让复用在 L1/L2/L3 内生效，将 DRAM 流量降到 $ MK + KN + 2MN $ 的量级。</li><li>OpenMP 在多核扩展吞吐，但需注意带宽瓶颈与 NUMA。</li></ol></li><li><p>在内存主导模型下的理论加速（相对 naive）：</p><ul><li>$ 1 \times 4 $：约 $ 3.2 \times $。</li><li>$ 4 \times 4 $：约 $ 8 \times $。</li><li>分块 + 打包：约 $ \frac{4MNK+MN}{MK+KN+2MN} $（方阵近似 $ n $）。</li><li>SIMD 与 OpenMP 的收益叠加取决于是否进入计算主导。</li></ul></li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://github.com/flame/how-to-optimize-gemm/wiki>How to optimize GEMM</a>（FLAME wiki）</li><li><a href=https://zhenhuaw.me/blog/2019/gemm-optimization.html>通用矩阵乘（GEMM）优化算法</a></li><li><a href=https://www.openblas.net>OpenBLAS</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://diefish1024.github.io/tags/cs/>CS</a></li><li><a href=https://diefish1024.github.io/tags/hpc/>HPC</a></li></ul><nav class=paginav><a class=prev href=https://diefish1024.github.io/posts/math2701-%E6%A6%82%E7%8E%87%E8%AE%BA/lect1-%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/><span class=title>« Prev</span><br><span>Lect1-课程简介</span>
</a><a class=next href=https://diefish1024.github.io/posts/hpc/%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98/><span class=title>Next »</span><br><span>关于内存</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share GEMM 算法优化 on x" href="https://x.com/intent/tweet/?text=GEMM%20%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f&amp;hashtags=CS%2cHPC"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GEMM 算法优化 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f&amp;title=GEMM%20%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96&amp;summary=GEMM%20%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96&amp;source=https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GEMM 算法优化 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f&title=GEMM%20%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GEMM 算法优化 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GEMM 算法优化 on whatsapp" href="https://api.whatsapp.com/send?text=GEMM%20%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96%20-%20https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GEMM 算法优化 on telegram" href="https://telegram.me/share/url?text=GEMM%20%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GEMM 算法优化 on ycombinator" href="https://news.ycombinator.com/submitlink?t=GEMM%20%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96&u=https%3a%2f%2fdiefish1024.github.io%2fposts%2fhpc%2fgemm-%25E7%25AE%2597%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://diefish1024.github.io/>diefish's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>