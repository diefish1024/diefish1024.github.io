<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>20. 设备和驱动程序 | diefish's blog</title><meta name=keywords content="learning,CS,nju-os"><meta name=description content="输入输出设备
Everything is a File
在 Unix-like 系统中，与外部设备交互的核心思想是 Everything is a File


文件描述符 (File Descriptor)：操作系统为上层软件提供了一个统一的抽象，即文件描述符，它是一个指向内核中任何 I/O 对象的“指针”或句柄


统一接口：无论是普通文件、硬件设备（如终端、磁盘）、还是网络连接，都可以通过 open 获得一个文件描述符，然后使用相同的 read/write 等系统调用来进行操作，这极大地简化了应用程序的编写


设备控制器与 MMIO
“文件”这个美好的抽象背后，是具体的硬件工作原理


设备控制器 (Device Controller)：每个 I/O 设备都有一个控制器，它是一个包含 CPU、内存和寄存器的微型计算机，作为 CPU 和物理设备之间的桥梁


设备寄存器：控制器通过一组寄存器与 CPU 通信，通常包括：

状态寄存器：用于表示设备当前是否繁忙、是否准备好等
指令寄存器：CPU 写入指令，告诉设备要做什么
数据寄存器：用于在 CPU 和设备之间传输数据



内存映射 I/O (MMIO)：为了让 CPU 能访问这些寄存器，现代系统普遍采用 MMIO (Memory-Mapped I/O)，操作系统会将设备的寄存器映射到物理内存地址空间中的特定区域，这样一来，CPU 就可以像访问普通内存一样，使用标准的 load/store 指令来读写设备寄存器，从而实现对设备的控制


GPIO
GPIO (General-Purpose Input/Output) 是理解 I/O 设备原理最直观的例子，GPIO 就是一个物理引脚，可以通过编程设置为输入或输出模式
通过 MMIO，一个 GPIO 引脚的电平状态被映射到一个特定的内存地址，当 CPU 向这个地址写入 1 时，引脚就变为高电平；写入 0 时，则变为低电平，这个过程将一条内存写指令直接转化为了一个物理世界的动作（比如点亮一个 LED）"><meta name=author content="diefish"><link rel=canonical href=https://diefish1024.github.io/posts/class-notes/nju-os-2025/20-%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.7e33168b13c822c8560dd6cce14b81ffdf7b6c118596a21d43f319d693f61534.css integrity="sha256-fjMWixPIIshWDdbM4UuB/997bBGFlqIdQ/MZ1pP2FTQ=" rel="preload stylesheet" as=style><link rel=icon href=https://diefish1024.github.io/images/avatar.jpg><link rel=icon type=image/png sizes=16x16 href=https://diefish1024.github.io/images/avatar.jpg><link rel=icon type=image/png sizes=32x32 href=https://diefish1024.github.io/images/avatar.jpg><link rel=apple-touch-icon href=https://diefish1024.github.io/images/avatar.jpg><link rel=mask-icon href=https://diefish1024.github.io/images/avatar.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://diefish1024.github.io/posts/class-notes/nju-os-2025/20-%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://diefish1024.github.io/posts/class-notes/nju-os-2025/20-%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"><meta property="og:site_name" content="diefish's blog"><meta property="og:title" content="20. 设备和驱动程序"><meta property="og:description" content="输入输出设备 Everything is a File 在 Unix-like 系统中，与外部设备交互的核心思想是 Everything is a File
文件描述符 (File Descriptor)：操作系统为上层软件提供了一个统一的抽象，即文件描述符，它是一个指向内核中任何 I/O 对象的“指针”或句柄
统一接口：无论是普通文件、硬件设备（如终端、磁盘）、还是网络连接，都可以通过 open 获得一个文件描述符，然后使用相同的 read/write 等系统调用来进行操作，这极大地简化了应用程序的编写
设备控制器与 MMIO “文件”这个美好的抽象背后，是具体的硬件工作原理
设备控制器 (Device Controller)：每个 I/O 设备都有一个控制器，它是一个包含 CPU、内存和寄存器的微型计算机，作为 CPU 和物理设备之间的桥梁
设备寄存器：控制器通过一组寄存器与 CPU 通信，通常包括：
状态寄存器：用于表示设备当前是否繁忙、是否准备好等 指令寄存器：CPU 写入指令，告诉设备要做什么 数据寄存器：用于在 CPU 和设备之间传输数据 内存映射 I/O (MMIO)：为了让 CPU 能访问这些寄存器，现代系统普遍采用 MMIO (Memory-Mapped I/O)，操作系统会将设备的寄存器映射到物理内存地址空间中的特定区域，这样一来，CPU 就可以像访问普通内存一样，使用标准的 load/store 指令来读写设备寄存器，从而实现对设备的控制
GPIO GPIO (General-Purpose Input/Output) 是理解 I/O 设备原理最直观的例子，GPIO 就是一个物理引脚，可以通过编程设置为输入或输出模式
通过 MMIO，一个 GPIO 引脚的电平状态被映射到一个特定的内存地址，当 CPU 向这个地址写入 1 时，引脚就变为高电平；写入 0 时，则变为低电平，这个过程将一条内存写指令直接转化为了一个物理世界的动作（比如点亮一个 LED）"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-03T16:54:00+08:00"><meta property="article:modified_time" content="2025-08-03T16:54:00+08:00"><meta property="article:tag" content="Learning"><meta property="article:tag" content="CS"><meta property="article:tag" content="Nju-Os"><meta property="og:image" content="https://diefish1024.github.io/images/avatar.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://diefish1024.github.io/images/avatar.jpg"><meta name=twitter:title content="20. 设备和驱动程序"><meta name=twitter:description content="输入输出设备
Everything is a File
在 Unix-like 系统中，与外部设备交互的核心思想是 Everything is a File


文件描述符 (File Descriptor)：操作系统为上层软件提供了一个统一的抽象，即文件描述符，它是一个指向内核中任何 I/O 对象的“指针”或句柄


统一接口：无论是普通文件、硬件设备（如终端、磁盘）、还是网络连接，都可以通过 open 获得一个文件描述符，然后使用相同的 read/write 等系统调用来进行操作，这极大地简化了应用程序的编写


设备控制器与 MMIO
“文件”这个美好的抽象背后，是具体的硬件工作原理


设备控制器 (Device Controller)：每个 I/O 设备都有一个控制器，它是一个包含 CPU、内存和寄存器的微型计算机，作为 CPU 和物理设备之间的桥梁


设备寄存器：控制器通过一组寄存器与 CPU 通信，通常包括：

状态寄存器：用于表示设备当前是否繁忙、是否准备好等
指令寄存器：CPU 写入指令，告诉设备要做什么
数据寄存器：用于在 CPU 和设备之间传输数据



内存映射 I/O (MMIO)：为了让 CPU 能访问这些寄存器，现代系统普遍采用 MMIO (Memory-Mapped I/O)，操作系统会将设备的寄存器映射到物理内存地址空间中的特定区域，这样一来，CPU 就可以像访问普通内存一样，使用标准的 load/store 指令来读写设备寄存器，从而实现对设备的控制


GPIO
GPIO (General-Purpose Input/Output) 是理解 I/O 设备原理最直观的例子，GPIO 就是一个物理引脚，可以通过编程设置为输入或输出模式
通过 MMIO，一个 GPIO 引脚的电平状态被映射到一个特定的内存地址，当 CPU 向这个地址写入 1 时，引脚就变为高电平；写入 0 时，则变为低电平，这个过程将一条内存写指令直接转化为了一个物理世界的动作（比如点亮一个 LED）"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://diefish1024.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Class Notes","item":"https://diefish1024.github.io/posts/class-notes/"},{"@type":"ListItem","position":3,"name":"NJU OS 2025","item":"https://diefish1024.github.io/posts/class-notes/nju-os-2025/"},{"@type":"ListItem","position":4,"name":"20. 设备和驱动程序","item":"https://diefish1024.github.io/posts/class-notes/nju-os-2025/20-%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"20. 设备和驱动程序","name":"20. 设备和驱动程序","description":"输入输出设备 Everything is a File 在 Unix-like 系统中，与外部设备交互的核心思想是 Everything is a File\n文件描述符 (File Descriptor)：操作系统为上层软件提供了一个统一的抽象，即文件描述符，它是一个指向内核中任何 I/O 对象的“指针”或句柄\n统一接口：无论是普通文件、硬件设备（如终端、磁盘）、还是网络连接，都可以通过 open 获得一个文件描述符，然后使用相同的 read/write 等系统调用来进行操作，这极大地简化了应用程序的编写\n设备控制器与 MMIO “文件”这个美好的抽象背后，是具体的硬件工作原理\n设备控制器 (Device Controller)：每个 I/O 设备都有一个控制器，它是一个包含 CPU、内存和寄存器的微型计算机，作为 CPU 和物理设备之间的桥梁\n设备寄存器：控制器通过一组寄存器与 CPU 通信，通常包括：\n状态寄存器：用于表示设备当前是否繁忙、是否准备好等 指令寄存器：CPU 写入指令，告诉设备要做什么 数据寄存器：用于在 CPU 和设备之间传输数据 内存映射 I/O (MMIO)：为了让 CPU 能访问这些寄存器，现代系统普遍采用 MMIO (Memory-Mapped I/O)，操作系统会将设备的寄存器映射到物理内存地址空间中的特定区域，这样一来，CPU 就可以像访问普通内存一样，使用标准的 load/store 指令来读写设备寄存器，从而实现对设备的控制\nGPIO GPIO (General-Purpose Input/Output) 是理解 I/O 设备原理最直观的例子，GPIO 就是一个物理引脚，可以通过编程设置为输入或输出模式\n通过 MMIO，一个 GPIO 引脚的电平状态被映射到一个特定的内存地址，当 CPU 向这个地址写入 1 时，引脚就变为高电平；写入 0 时，则变为低电平，这个过程将一条内存写指令直接转化为了一个物理世界的动作（比如点亮一个 LED）\n","keywords":["learning","CS","nju-os"],"articleBody":"输入输出设备 Everything is a File 在 Unix-like 系统中，与外部设备交互的核心思想是 Everything is a File\n文件描述符 (File Descriptor)：操作系统为上层软件提供了一个统一的抽象，即文件描述符，它是一个指向内核中任何 I/O 对象的“指针”或句柄\n统一接口：无论是普通文件、硬件设备（如终端、磁盘）、还是网络连接，都可以通过 open 获得一个文件描述符，然后使用相同的 read/write 等系统调用来进行操作，这极大地简化了应用程序的编写\n设备控制器与 MMIO “文件”这个美好的抽象背后，是具体的硬件工作原理\n设备控制器 (Device Controller)：每个 I/O 设备都有一个控制器，它是一个包含 CPU、内存和寄存器的微型计算机，作为 CPU 和物理设备之间的桥梁\n设备寄存器：控制器通过一组寄存器与 CPU 通信，通常包括：\n状态寄存器：用于表示设备当前是否繁忙、是否准备好等 指令寄存器：CPU 写入指令，告诉设备要做什么 数据寄存器：用于在 CPU 和设备之间传输数据 内存映射 I/O (MMIO)：为了让 CPU 能访问这些寄存器，现代系统普遍采用 MMIO (Memory-Mapped I/O)，操作系统会将设备的寄存器映射到物理内存地址空间中的特定区域，这样一来，CPU 就可以像访问普通内存一样，使用标准的 load/store 指令来读写设备寄存器，从而实现对设备的控制\nGPIO GPIO (General-Purpose Input/Output) 是理解 I/O 设备原理最直观的例子，GPIO 就是一个物理引脚，可以通过编程设置为输入或输出模式\n通过 MMIO，一个 GPIO 引脚的电平状态被映射到一个特定的内存地址，当 CPU 向这个地址写入 1 时，引脚就变为高电平；写入 0 时，则变为低电平，这个过程将一条内存写指令直接转化为了一个物理世界的动作（比如点亮一个 LED）\n输入输出设备案例 串口与键盘 经典的 I/O 设备，展示了最基础的设备交互方式\n端口 I/O：它们通常使用端口 I/O (Port I/O) 与 CPU 通信，设备寄存器被映射到专用的 I/O 端口地址（而非内存地址），CPU 需要使用特殊的 in/out 指令来读写这些端口\n向指定端口写入不同的数值，相当于向设备发送不同的指令（如设置波特率、控制键盘 LED 灯），而从指定端口读取数据则是接收设备的状态或输入（如串口收到的字符、键盘按键的扫描码）\n磁盘控制器与 PIO 早期的磁盘控制器（如 ATA/IDE）展示了一种更复杂但效率较低的交互模式：PIO 协议：全称为Programmed I/O，在这种模式下，数据的传输完全由 CPU 控制\n工作流程：\nCPU 向磁盘控制器的指令寄存器写入命令（如“读取第 N 个扇区”） CPU 进入轮询 (Polling) 状态，反复读取状态寄存器，直到设备报告“数据准备就绪” CPU 在一个循环中，逐个字节或字地将数据从磁盘的数据寄存器读入 CPU 寄存器，再写入内存 缺点：在轮询和数据传输期间，CPU 被完全占用，无法执行其他任务，效率极其低下\n打印机与 DSL 打印机这类设备，将交互模型提升到了一个新的高度\n领域专用语言 (DSL)：打印机不是简单地接收像素数据，而是作为一个独立的计算机，接收并解释用页面描述语言（如 PostScript 或 PCL）编写的“程序”\nCPU（驱动程序）的角色更像是一个编译器，将应用程序的打印请求（如一个 Word 文档）编译成一串 PostScript 指令流，然后发送给打印机\n打印机内部的处理器负责执行这些指令，将抽象的描述（如“在这里画一条线”、“使用这个字体显示文本”）翻译成打印头的物理动作\n总线与可扩展性 单个计算机系统需要连接多种多样的设备，这就需要一个标准化的扩展机制——总线 (Bus)\n总线是一组共享的电子线路，它定义了一套协议，允许 CPU、内存和多个 I/O 设备之间进行通信，它提供了一种“设备虚拟化”，CPU 只需与总线控制器通信，由总线负责将请求转发到正确的设备\n可扩展性：通过标准的扩展插槽（如早期的 ISA、现代的 PCIe），用户可以向系统中添加无穷无尽的新设备，而无需修改主板或 CPU 的设计 PCIe 总线与 DMA PCIe (PCI Express) 是目前主流的高速总线标准，它引入了一项革命性的技术来解决 PIO 的效率问题：DMA，全称为直接内存访问 (Direct Memory Access)，它允许设备控制器在没有 CPU 干预的情况下，直接与主内存进行数据传输\n工作流程：\nCPU 设置 DMA 控制器，告诉它源地址、目标地址和传输大小 CPU 向设备发出“开始传输”的指令后，就可以去执行其他任务了 DMA 控制器全权负责数据的搬运 传输完成后，DMA 控制器通过中断通知 CPU 优势：DMA 极大地解放了 CPU，使其不需要负责搬运数据，从而显著提升了整个系统的 I/O 吞吐量和效率，是所有现代高性能设备（显卡、NVMe 硬盘、高速网卡）的基础\n设备驱动程序 file_operations 结构体 操作系统内核通过名为 file_operations 的结构体落实“Everything is a File”的思想\n核心机制：这个结构体本质上是一个函数指针列表，定义了一系列标准的文件操作，如 read, write, open, llseek, ioctl 等\n驱动的本质：一个设备驱动程序 (Device Driver) 的核心，就是为特定的硬件或虚拟设备，提供一套具体的 file_operations 实现，当一个设备被注册到系统中时，内核就会将这个设备的“文件”与这套操作函数关联起来\n驱动的翻译职责 设备驱动程序的核心职责，就是翻译应用程序和物理硬件之间的交互\n翻译过程：当一个用户程序对文件描述符执行系统调用时（例如 read(fd, buf, size)），内核会：\n通过 fd 找到对应的内核文件对象 从文件对象中找到关联的 file_operations 结构体 调用其中的 .read 函数指针，并将系统调用的参数传递过去 驱动的实现：驱动程序中的 .read 函数则负责执行设备相关的底层操作，比如通过 MMIO 或 PIO 向设备控制器发送指令，等待数据就绪，然后将数据从设备寄存器中读出，最后复制到用户空间的 buf 中\n虚拟设备：这个模型同样适用于虚拟设备，例如对 /dev/null 的 write 操作，其驱动实现仅仅是直接返回写入的字节数，而什么也不做，对 /proc/stat 的 read 操作，则是读取内核中的统计数据并格式化成字符串返回\nioctl 万能接口 对于读写数据流之外的设备控制和配置需求（如设置键盘重复率、获取磁盘健康信息、配置网络参数等），read/write 模型显然不能满足，为此，Unix 系统提供了一个通用的 ioctl (I/O Control) 系统调用\nioctl 是一个高度灵活的接口，它的具体行为完全由设备驱动程序定义，应用程序通过传递一个设备专属的命令码和参数，来执行特定的控制功能\n虽然强大，但 ioctl 也带来了巨大的复杂性，因为每个设备的命令集都不同，形成了一系列隐藏的、非标准的协议，应用程序需要知道这些细节才能与设备深度交互（是巨大的屎山💩）\n实际案例：\nlibc 缓冲：libc 库通过对文件描述符 1 (stdout) 执行一个 tty 设备专属的 ioctl 命令（如 TCGETS），来判断输出目标是否为一个交互式终端，从而决定是采用行缓冲还是全缓冲\nKVM 虚拟化：KVM 就是一个通过 ioctl 暴露全部功能的复杂设备，用户程序打开 /dev/kvm 后，通过一系列 ioctl 命令（如 KVM_CREATE_VM, KVM_SET_REGS, KVM_RUN）来创建虚拟机、设定 CPU 状态并运行虚拟机，直到发生 VM Exit 事件返回到用户态\n","wordCount":"273","inLanguage":"en","image":"https://diefish1024.github.io/images/avatar.jpg","datePublished":"2025-08-03T16:54:00+08:00","dateModified":"2025-08-03T16:54:00+08:00","author":{"@type":"Person","name":"diefish"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diefish1024.github.io/posts/class-notes/nju-os-2025/20-%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"},"publisher":{"@type":"Organization","name":"diefish's blog","logo":{"@type":"ImageObject","url":"https://diefish1024.github.io/images/avatar.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diefish1024.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://diefish1024.github.io/images/avatar.jpg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diefish1024.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://diefish1024.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://diefish1024.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://diefish1024.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://diefish1024.github.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://diefish1024.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://diefish1024.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://diefish1024.github.io/posts/class-notes/>Class Notes</a>&nbsp;»&nbsp;<a href=https://diefish1024.github.io/posts/class-notes/nju-os-2025/>NJU OS 2025</a></div><h1 class="post-title entry-hint-parent">20. 设备和驱动程序</h1><div class=post-meta><span title='2025-08-03 16:54:00 +0800 +0800'>August 3, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;diefish&nbsp;|&nbsp;<a href=https://github.com/diefish1024/diefish1024.github.io/blob/main/content/posts/Class%20Notes/nju-os-2025/20-%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e8%ae%be%e5%a4%87 aria-label=输入输出设备>输入输出设备</a><ul><li><a href=#everything-is-a-file aria-label="Everything is a File">Everything is a File</a></li><li><a href=#%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%99%a8%e4%b8%8e-mmio aria-label="设备控制器与 MMIO">设备控制器与 MMIO</a></li><li><a href=#gpio aria-label=GPIO>GPIO</a></li></ul></li><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e8%ae%be%e5%a4%87%e6%a1%88%e4%be%8b aria-label=输入输出设备案例>输入输出设备案例</a><ul><li><a href=#%e4%b8%b2%e5%8f%a3%e4%b8%8e%e9%94%ae%e7%9b%98 aria-label=串口与键盘>串口与键盘</a></li><li><a href=#%e7%a3%81%e7%9b%98%e6%8e%a7%e5%88%b6%e5%99%a8%e4%b8%8e-pio aria-label="磁盘控制器与 PIO">磁盘控制器与 PIO</a></li><li><a href=#%e6%89%93%e5%8d%b0%e6%9c%ba%e4%b8%8e-dsl aria-label="打印机与 DSL">打印机与 DSL</a></li><li><a href=#%e6%80%bb%e7%ba%bf%e4%b8%8e%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7 aria-label=总线与可扩展性>总线与可扩展性</a></li><li><a href=#pcie-%e6%80%bb%e7%ba%bf%e4%b8%8e-dma aria-label="PCIe 总线与 DMA">PCIe 总线与 DMA</a></li></ul></li><li><a href=#%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f aria-label=设备驱动程序>设备驱动程序</a><ul><li><a href=#file_operations-%e7%bb%93%e6%9e%84%e4%bd%93 aria-label="file_operations 结构体">file_operations 结构体</a></li><li><a href=#%e9%a9%b1%e5%8a%a8%e7%9a%84%e7%bf%bb%e8%af%91%e8%81%8c%e8%b4%a3 aria-label=驱动的翻译职责>驱动的翻译职责</a></li><li><a href=#ioctl-%e4%b8%87%e8%83%bd%e6%8e%a5%e5%8f%a3 aria-label="ioctl 万能接口">ioctl 万能接口</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=输入输出设备>输入输出设备<a hidden class=anchor aria-hidden=true href=#输入输出设备>#</a></h2><h3 id=everything-is-a-file>Everything is a File<a hidden class=anchor aria-hidden=true href=#everything-is-a-file>#</a></h3><p>在 Unix-like 系统中，与外部设备交互的核心思想是 <strong>Everything is a File</strong></p><ul><li><p><strong>文件描述符 (File Descriptor)</strong>：操作系统为上层软件提供了一个统一的抽象，即文件描述符，它是一个指向内核中任何 I/O 对象的“指针”或句柄</p></li><li><p><strong>统一接口</strong>：无论是普通文件、硬件设备（如终端、磁盘）、还是网络连接，都可以通过 <code>open</code> 获得一个文件描述符，然后使用相同的 <code>read</code>/<code>write</code> 等系统调用来进行操作，这极大地简化了应用程序的编写</p></li></ul><h3 id=设备控制器与-mmio>设备控制器与 MMIO<a hidden class=anchor aria-hidden=true href=#设备控制器与-mmio>#</a></h3><p>“文件”这个美好的抽象背后，是具体的硬件工作原理</p><ul><li><p><strong>设备控制器 (Device Controller)</strong>：每个 I/O 设备都有一个控制器，它是一个包含 CPU、内存和寄存器的微型计算机，作为 CPU 和物理设备之间的桥梁</p></li><li><p><strong>设备寄存器</strong>：控制器通过一组<strong>寄存器</strong>与 CPU 通信，通常包括：</p><ul><li><strong>状态寄存器</strong>：用于表示设备当前是否繁忙、是否准备好等</li><li><strong>指令寄存器</strong>：CPU 写入指令，告诉设备要做什么</li><li><strong>数据寄存器</strong>：用于在 CPU 和设备之间传输数据</li></ul></li><li><p><strong>内存映射 I/O (MMIO)</strong>：为了让 CPU 能访问这些寄存器，现代系统普遍采用 <strong>MMIO (Memory-Mapped I/O)</strong>，操作系统会将设备的寄存器映射到物理内存地址空间中的特定区域，这样一来，CPU 就可以像访问普通内存一样，使用标准的 <code>load</code>/<code>store</code> 指令来读写设备寄存器，从而实现对设备的控制</p></li></ul><h3 id=gpio>GPIO<a hidden class=anchor aria-hidden=true href=#gpio>#</a></h3><p><strong>GPIO (General-Purpose Input/Output)</strong> 是理解 I/O 设备原理最直观的例子，GPIO 就是一个物理引脚，可以通过编程设置为输入或输出模式</p><p>通过 MMIO，一个 GPIO 引脚的电平状态被映射到一个特定的内存地址，当 CPU 向这个地址写入 <code>1</code> 时，引脚就变为高电平；写入 <code>0</code> 时，则变为低电平，这个过程将一条内存写指令直接转化为了一个物理世界的动作（比如点亮一个 LED）</p><h2 id=输入输出设备案例>输入输出设备案例<a hidden class=anchor aria-hidden=true href=#输入输出设备案例>#</a></h2><h3 id=串口与键盘>串口与键盘<a hidden class=anchor aria-hidden=true href=#串口与键盘>#</a></h3><p>经典的 I/O 设备，展示了最基础的设备交互方式</p><p><strong>端口 I/O</strong>：它们通常使用<strong>端口 I/O (Port I/O)</strong> 与 CPU 通信，设备寄存器被映射到专用的 I/O 端口地址（而非内存地址），CPU 需要使用特殊的 <code>in</code>/<code>out</code> 指令来读写这些端口</p><p>向指定端口写入不同的数值，相当于向设备发送不同的<strong>指令</strong>（如设置波特率、控制键盘 LED 灯），而从指定端口读取数据则是接收设备的状态或输入（如串口收到的字符、键盘按键的扫描码）</p><h3 id=磁盘控制器与-pio>磁盘控制器与 PIO<a hidden class=anchor aria-hidden=true href=#磁盘控制器与-pio>#</a></h3><p>早期的磁盘控制器（如 ATA/IDE）展示了一种更复杂但效率较低的交互模式：<strong>PIO 协议</strong>：全称为<strong>Programmed I/O</strong>，在这种模式下，数据的传输完全由 CPU 控制</p><p><strong>工作流程</strong>：</p><ol><li>CPU 向磁盘控制器的指令寄存器写入命令（如“读取第 N 个扇区”）</li><li>CPU 进入<strong>轮询 (Polling)</strong> 状态，反复读取状态寄存器，直到设备报告“数据准备就绪”</li><li>CPU 在一个循环中，逐个字节或字地将数据从磁盘的数据寄存器读入 CPU 寄存器，再写入内存</li></ol><p><strong>缺点</strong>：在轮询和数据传输期间，CPU 被完全占用，无法执行其他任务，<strong>效率极其低下</strong></p><h3 id=打印机与-dsl>打印机与 DSL<a hidden class=anchor aria-hidden=true href=#打印机与-dsl>#</a></h3><p>打印机这类设备，将交互模型提升到了一个新的高度</p><p><strong>领域专用语言 (DSL)</strong>：打印机不是简单地接收像素数据，而是作为一个独立的计算机，接收并解释用<strong>页面描述语言</strong>（如 PostScript 或 PCL）编写的“程序”</p><p>CPU（驱动程序）的角色更像是一个编译器，将应用程序的打印请求（如一个 Word 文档）编译成一串 PostScript 指令流，然后发送给打印机</p><p>打印机内部的处理器负责执行这些指令，将抽象的描述（如“在这里画一条线”、“使用这个字体显示文本”）翻译成打印头的物理动作</p><h3 id=总线与可扩展性>总线与可扩展性<a hidden class=anchor aria-hidden=true href=#总线与可扩展性>#</a></h3><p>单个计算机系统需要连接多种多样的设备，这就需要一个标准化的扩展机制——<strong>总线 (Bus)</strong></p><p>总线是一组共享的电子线路，它定义了一套协议，允许 CPU、内存和多个 I/O 设备之间进行通信，它提供了一种“设备虚拟化”，CPU 只需与总线控制器通信，由总线负责将请求转发到正确的设备</p><ul><li><strong>可扩展性</strong>：通过标准的扩展插槽（如早期的 ISA、现代的 PCIe），用户可以向系统中添加无穷无尽的新设备，而无需修改主板或 CPU 的设计</li></ul><h3 id=pcie-总线与-dma>PCIe 总线与 DMA<a hidden class=anchor aria-hidden=true href=#pcie-总线与-dma>#</a></h3><p><strong>PCIe (PCI Express)</strong> 是目前主流的高速总线标准，它引入了一项革命性的技术来解决 PIO 的效率问题：<strong>DMA</strong>，全称为<strong>直接内存访问 (Direct Memory Access)</strong>，它允许设备控制器在没有 CPU 干预的情况下，直接与主内存进行数据传输</p><p><strong>工作流程</strong>：</p><ol><li>CPU 设置 DMA 控制器，告诉它源地址、目标地址和传输大小</li><li>CPU 向设备发出“开始传输”的指令后，就可以<strong>去执行其他任务</strong>了</li><li>DMA 控制器全权负责数据的搬运</li><li>传输完成后，DMA 控制器通过<strong>中断</strong>通知 CPU</li></ol><p><strong>优势</strong>：DMA 极大地解放了 CPU，使其不需要负责搬运数据，从而显著提升了整个系统的 I/O 吞吐量和效率，是所有现代高性能设备（显卡、NVMe 硬盘、高速网卡）的基础</p><h2 id=设备驱动程序>设备驱动程序<a hidden class=anchor aria-hidden=true href=#设备驱动程序>#</a></h2><h3 id=file_operations-结构体>file_operations 结构体<a hidden class=anchor aria-hidden=true href=#file_operations-结构体>#</a></h3><p>操作系统内核通过名为 <code>file_operations</code> 的结构体落实“Everything is a File”的思想</p><p><strong>核心机制</strong>：这个结构体本质上是一个<strong>函数指针列表</strong>，定义了一系列标准的文件操作，如 <code>read</code>, <code>write</code>, <code>open</code>, <code>llseek</code>, <code>ioctl</code> 等</p><p><strong>驱动的本质</strong>：一个<strong>设备驱动程序 (Device Driver)</strong> 的核心，就是为特定的硬件或虚拟设备，提供一套具体的 <code>file_operations</code> 实现，当一个设备被注册到系统中时，内核就会将这个设备的“文件”与这套操作函数关联起来</p><h3 id=驱动的翻译职责>驱动的翻译职责<a hidden class=anchor aria-hidden=true href=#驱动的翻译职责>#</a></h3><p>设备驱动程序的核心职责，就是<strong>翻译</strong>应用程序和物理硬件之间的交互</p><p><strong>翻译过程</strong>：当一个用户程序对文件描述符执行系统调用时（例如 <code>read(fd, buf, size)</code>），内核会：</p><ol><li>通过 <code>fd</code> 找到对应的内核文件对象</li><li>从文件对象中找到关联的 <code>file_operations</code> 结构体</li><li>调用其中的 <code>.read</code> 函数指针，并将系统调用的参数传递过去</li></ol><p><strong>驱动的实现</strong>：驱动程序中的 <code>.read</code> 函数则负责执行设备相关的底层操作，比如通过 <strong>MMIO</strong> 或 <strong>PIO</strong> 向设备控制器发送指令，等待数据就绪，然后将数据从设备寄存器中读出，最后复制到用户空间的 <code>buf</code> 中</p><p><strong>虚拟设备</strong>：这个模型同样适用于虚拟设备，例如对 <code>/dev/null</code> 的 <code>write</code> 操作，其驱动实现仅仅是直接返回写入的字节数，而什么也不做，对 <code>/proc/stat</code> 的 <code>read</code> 操作，则是读取内核中的统计数据并格式化成字符串返回</p><h3 id=ioctl-万能接口>ioctl 万能接口<a hidden class=anchor aria-hidden=true href=#ioctl-万能接口>#</a></h3><p>对于读写数据流之外的设备控制和配置需求（如设置键盘重复率、获取磁盘健康信息、配置网络参数等），<code>read</code>/<code>write</code> 模型显然不能满足，为此，Unix 系统提供了一个通用的 <strong><code>ioctl</code> (I/O Control)</strong> 系统调用</p><p><code>ioctl</code> 是一个高度灵活的接口，它的具体行为完全由设备驱动程序定义，应用程序通过传递一个设备专属的<strong>命令码</strong>和参数，来执行特定的控制功能</p><p>虽然强大，但 <code>ioctl</code> 也带来了巨大的复杂性，因为每个设备的命令集都不同，形成了一系列隐藏的、非标准的协议，应用程序需要知道这些细节才能与设备深度交互（是巨大的屎山💩）</p><p><strong>实际案例</strong>：</p><ul><li><p><strong>libc 缓冲</strong>：libc 库通过对文件描述符 <code>1</code> (stdout) 执行一个 tty 设备专属的 <code>ioctl</code> 命令（如 <code>TCGETS</code>），来判断输出目标是否为一个交互式终端，从而决定是采用行缓冲还是全缓冲</p></li><li><p><strong>KVM 虚拟化</strong>：KVM 就是一个通过 <code>ioctl</code> 暴露全部功能的复杂设备，用户程序打开 <code>/dev/kvm</code> 后，通过一系列 <code>ioctl</code> 命令（如 <code>KVM_CREATE_VM</code>, <code>KVM_SET_REGS</code>, <code>KVM_RUN</code>）来创建虚拟机、设定 CPU 状态并运行虚拟机，直到发生 <strong>VM Exit</strong> 事件返回到用户态</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://diefish1024.github.io/tags/learning/>Learning</a></li><li><a href=https://diefish1024.github.io/tags/cs/>CS</a></li><li><a href=https://diefish1024.github.io/tags/nju-os/>Nju-Os</a></li></ul><nav class=paginav><a class=prev href=https://diefish1024.github.io/posts/class-notes/nju-os-2025/21-%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%8E%9F%E7%90%86/><span class=title>« Prev</span><br><span>21. 存储设备原理</span>
</a><a class=next href=https://diefish1024.github.io/posts/class-notes/nju-os-2025/19-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-2/><span class=title>Next »</span><br><span>19. 真实世界的并发编程 (2)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 20. 设备和驱动程序 on x" href="https://x.com/intent/tweet/?text=20.%20%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f&amp;hashtags=learning%2cCS%2cnju-os"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 20. 设备和驱动程序 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f&amp;title=20.%20%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f&amp;summary=20.%20%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f&amp;source=https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 20. 设备和驱动程序 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f&title=20.%20%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 20. 设备和驱动程序 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 20. 设备和驱动程序 on whatsapp" href="https://api.whatsapp.com/send?text=20.%20%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f%20-%20https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 20. 设备和驱动程序 on telegram" href="https://telegram.me/share/url?text=20.%20%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 20. 设备和驱动程序 on ycombinator" href="https://news.ycombinator.com/submitlink?t=20.%20%e8%ae%be%e5%a4%87%e5%92%8c%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f&u=https%3a%2f%2fdiefish1024.github.io%2fposts%2fclass-notes%2fnju-os-2025%2f20-%25E8%25AE%25BE%25E5%25A4%2587%25E5%2592%258C%25E9%25A9%25B1%25E5%258A%25A8%25E7%25A8%258B%25E5%25BA%258F%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://diefish1024.github.io/>diefish's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>