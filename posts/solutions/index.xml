<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Solutions on diefish&#39;s blog</title>
    <link>https://diefish1024.github.io/posts/solutions/</link>
    <description>Recent content in Solutions on diefish&#39;s blog</description>
    <image>
      <title>diefish&#39;s blog</title>
      <url>https://diefish1024.github.io/images/avatar.jpg</url>
      <link>https://diefish1024.github.io/images/avatar.jpg</link>
    </image>
    <generator>Hugo -- 0.149.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 02 Sep 2025 16:15:00 +0800</lastBuildDate>
    <atom:link href="https://diefish1024.github.io/posts/solutions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Xflops2024-Bithack</title>
      <link>https://diefish1024.github.io/posts/solutions/xflops2024-bithack/</link>
      <pubDate>Tue, 02 Sep 2025 16:15:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/solutions/xflops2024-bithack/</guid>
      <description>&lt;p&gt;去年超算队招新唯一没有解决的一道题，今在 Gemini 老师的帮助下成功解决，决定重写一份题解报告。&lt;/p&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/HPC-SJTU/Xflops2024_1st_exam/tree/main/Bithack&#34;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目要求参赛者优化一个 C 语言函数 &lt;code&gt;rotate_the_bit_vector&lt;/code&gt;，函数功能是对一个 bit vector 中的一个指定子区间进行&lt;strong&gt;循环旋转&lt;/strong&gt;操作。&lt;/p&gt;
&lt;p&gt;具体而言，题目给的 &lt;code&gt;bit_vector&lt;/code&gt; 是一种内存紧凑的数据结构，将 8 个 bit 打包存储到一个字节中。参赛者需要在只修改 &lt;code&gt;submit_func.c&lt;/code&gt; 一个文件的前提下重写其中的 &lt;code&gt;rotate_the_bit_vector&lt;/code&gt; 函数，使其在大规模数据时尽可能快。&lt;/p&gt;
&lt;p&gt;最后评分程序会通过三个不同的 benchmark (&lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-m&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;) 来衡量，每个测试中的数据规模会随着层数的增加而几何级增长，最终的得分取决于规定时间内能到达的“层数”，层数越高。说明性能越好，最终分数也越高。&lt;/p&gt;
&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;
&lt;h3 id=&#34;three-reversal-algorithm&#34;&gt;Three-Reversal Algorithm&lt;/h3&gt;
&lt;p&gt;假设要移动的区间长度为 $ n $ ，需要移动 $ k $ 位；由于向右旋转 $ k $ 位可以等效于向左旋转 $ n-k $ 位，因此只讨论向左的移动。&lt;/p&gt;
&lt;p&gt;题目提供了一个初始的性能极差的实现，通过逐位移动 $ k $ 次来实现 $ k $ 位循环旋转，复杂度为 $ O(n^{2}) $。根据这个原始实现很容易想到一个初步的优化方案：&lt;/p&gt;
&lt;p&gt;问题的核心是把数组 &lt;code&gt;[A|B]&lt;/code&gt; 变成 &lt;code&gt;[B|A]&lt;/code&gt; ，一个经典的算法是&lt;strong&gt;三步翻转法&lt;/strong&gt;：如果我们把翻转操作记为 &lt;code&gt;&#39;&lt;/code&gt; ，&lt;code&gt;A&#39;&lt;/code&gt; 表示数组 &lt;code&gt;A&lt;/code&gt; 前后反转，那么可以发现原问题的操作实际上等价于三次翻转操作：&lt;code&gt;[A&#39;|B&#39;]&#39; = [B|A]&lt;/code&gt; ，复杂度为 $ O(n) $ ，代码如下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
