<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Xflops2024-Bithack | diefish's blog</title><meta name=keywords content="CS,HPC,solution"><meta name=description content="去年超算队招新唯一没有解决的一道题，今在 Gemini 老师的帮助下成功解决，决定重写一份题解报告。
Description
题目传送门
题目要求参赛者优化一个 C 语言函数 rotate_the_bit_vector，函数功能是对一个 bit vector 中的一个指定子区间进行循环旋转操作。
具体而言，题目给的 bit_vector 是一种内存紧凑的数据结构，将 8 个 bit 打包存储到一个字节中。参赛者需要在只修改 submit_func.c 一个文件的前提下重写其中的 rotate_the_bit_vector 函数，使其在大规模数据时尽可能快。
最后评分程序会通过三个不同的 benchmark (-s, -m, -l) 来衡量，每个测试中的数据规模会随着层数的增加而几何级增长，最终的得分取决于规定时间内能到达的“层数”，层数越高。说明性能越好，最终分数也越高。
Analysis
Three-Reversal Algorithm
假设要移动的区间长度为 $ n $ ，需要移动 $ k $ 位；由于向右旋转 $ k $ 位可以等效于向左旋转 $ n-k $ 位，因此只讨论向左的移动。
题目提供了一个初始的性能极差的实现，通过逐位移动 $ k $ 次来实现 $ k $ 位循环旋转，复杂度为 $ O(n^{2}) $。根据这个原始实现很容易想到一个初步的优化方案：
问题的核心是把数组 [A|B] 变成 [B|A] ，一个经典的算法是三步翻转法：如果我们把翻转操作记为 ' ，A' 表示数组 A 前后反转，那么可以发现原问题的操作实际上等价于三次翻转操作：[A'|B']' = [B|A] ，复杂度为 $ O(n) $ ，代码如下："><meta name=author content="diefish"><link rel=canonical href=https://diefish1024.github.io/posts/solutions/xflops2024-bithack/><link crossorigin=anonymous href=/assets/css/stylesheet.7e33168b13c822c8560dd6cce14b81ffdf7b6c118596a21d43f319d693f61534.css integrity="sha256-fjMWixPIIshWDdbM4UuB/997bBGFlqIdQ/MZ1pP2FTQ=" rel="preload stylesheet" as=style><link rel=icon href=https://diefish1024.github.io/images/avatar.jpg><link rel=icon type=image/png sizes=16x16 href=https://diefish1024.github.io/images/avatar.jpg><link rel=icon type=image/png sizes=32x32 href=https://diefish1024.github.io/images/avatar.jpg><link rel=apple-touch-icon href=https://diefish1024.github.io/images/avatar.jpg><link rel=mask-icon href=https://diefish1024.github.io/images/avatar.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://diefish1024.github.io/posts/solutions/xflops2024-bithack/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://diefish1024.github.io/posts/solutions/xflops2024-bithack/"><meta property="og:site_name" content="diefish's blog"><meta property="og:title" content="Xflops2024-Bithack"><meta property="og:description" content="去年超算队招新唯一没有解决的一道题，今在 Gemini 老师的帮助下成功解决，决定重写一份题解报告。
Description 题目传送门
题目要求参赛者优化一个 C 语言函数 rotate_the_bit_vector，函数功能是对一个 bit vector 中的一个指定子区间进行循环旋转操作。
具体而言，题目给的 bit_vector 是一种内存紧凑的数据结构，将 8 个 bit 打包存储到一个字节中。参赛者需要在只修改 submit_func.c 一个文件的前提下重写其中的 rotate_the_bit_vector 函数，使其在大规模数据时尽可能快。
最后评分程序会通过三个不同的 benchmark (-s, -m, -l) 来衡量，每个测试中的数据规模会随着层数的增加而几何级增长，最终的得分取决于规定时间内能到达的“层数”，层数越高。说明性能越好，最终分数也越高。
Analysis Three-Reversal Algorithm 假设要移动的区间长度为 $ n $ ，需要移动 $ k $ 位；由于向右旋转 $ k $ 位可以等效于向左旋转 $ n-k $ 位，因此只讨论向左的移动。
题目提供了一个初始的性能极差的实现，通过逐位移动 $ k $ 次来实现 $ k $ 位循环旋转，复杂度为 $ O(n^{2}) $。根据这个原始实现很容易想到一个初步的优化方案：
问题的核心是把数组 [A|B] 变成 [B|A] ，一个经典的算法是三步翻转法：如果我们把翻转操作记为 ' ，A' 表示数组 A 前后反转，那么可以发现原问题的操作实际上等价于三次翻转操作：[A'|B']' = [B|A] ，复杂度为 $ O(n) $ ，代码如下："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-02T16:15:00+08:00"><meta property="article:modified_time" content="2025-09-02T16:15:00+08:00"><meta property="article:tag" content="CS"><meta property="article:tag" content="HPC"><meta property="article:tag" content="Solution"><meta property="og:image" content="https://diefish1024.github.io/images/avatar.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://diefish1024.github.io/images/avatar.jpg"><meta name=twitter:title content="Xflops2024-Bithack"><meta name=twitter:description content="去年超算队招新唯一没有解决的一道题，今在 Gemini 老师的帮助下成功解决，决定重写一份题解报告。
Description
题目传送门
题目要求参赛者优化一个 C 语言函数 rotate_the_bit_vector，函数功能是对一个 bit vector 中的一个指定子区间进行循环旋转操作。
具体而言，题目给的 bit_vector 是一种内存紧凑的数据结构，将 8 个 bit 打包存储到一个字节中。参赛者需要在只修改 submit_func.c 一个文件的前提下重写其中的 rotate_the_bit_vector 函数，使其在大规模数据时尽可能快。
最后评分程序会通过三个不同的 benchmark (-s, -m, -l) 来衡量，每个测试中的数据规模会随着层数的增加而几何级增长，最终的得分取决于规定时间内能到达的“层数”，层数越高。说明性能越好，最终分数也越高。
Analysis
Three-Reversal Algorithm
假设要移动的区间长度为 $ n $ ，需要移动 $ k $ 位；由于向右旋转 $ k $ 位可以等效于向左旋转 $ n-k $ 位，因此只讨论向左的移动。
题目提供了一个初始的性能极差的实现，通过逐位移动 $ k $ 次来实现 $ k $ 位循环旋转，复杂度为 $ O(n^{2}) $。根据这个原始实现很容易想到一个初步的优化方案：
问题的核心是把数组 [A|B] 变成 [B|A] ，一个经典的算法是三步翻转法：如果我们把翻转操作记为 ' ，A' 表示数组 A 前后反转，那么可以发现原问题的操作实际上等价于三次翻转操作：[A'|B']' = [B|A] ，复杂度为 $ O(n) $ ，代码如下："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://diefish1024.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Solutions","item":"https://diefish1024.github.io/posts/solutions/"},{"@type":"ListItem","position":3,"name":"Xflops2024-Bithack","item":"https://diefish1024.github.io/posts/solutions/xflops2024-bithack/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Xflops2024-Bithack","name":"Xflops2024-Bithack","description":"去年超算队招新唯一没有解决的一道题，今在 Gemini 老师的帮助下成功解决，决定重写一份题解报告。\nDescription 题目传送门\n题目要求参赛者优化一个 C 语言函数 rotate_the_bit_vector，函数功能是对一个 bit vector 中的一个指定子区间进行循环旋转操作。\n具体而言，题目给的 bit_vector 是一种内存紧凑的数据结构，将 8 个 bit 打包存储到一个字节中。参赛者需要在只修改 submit_func.c 一个文件的前提下重写其中的 rotate_the_bit_vector 函数，使其在大规模数据时尽可能快。\n最后评分程序会通过三个不同的 benchmark (-s, -m, -l) 来衡量，每个测试中的数据规模会随着层数的增加而几何级增长，最终的得分取决于规定时间内能到达的“层数”，层数越高。说明性能越好，最终分数也越高。\nAnalysis Three-Reversal Algorithm 假设要移动的区间长度为 $ n $ ，需要移动 $ k $ 位；由于向右旋转 $ k $ 位可以等效于向左旋转 $ n-k $ 位，因此只讨论向左的移动。\n题目提供了一个初始的性能极差的实现，通过逐位移动 $ k $ 次来实现 $ k $ 位循环旋转，复杂度为 $ O(n^{2}) $。根据这个原始实现很容易想到一个初步的优化方案：\n问题的核心是把数组 [A|B] 变成 [B|A] ，一个经典的算法是三步翻转法：如果我们把翻转操作记为 ' ，A' 表示数组 A 前后反转，那么可以发现原问题的操作实际上等价于三次翻转操作：[A'|B']' = [B|A] ，复杂度为 $ O(n) $ ，代码如下：\n","keywords":["CS","HPC","solution"],"articleBody":"去年超算队招新唯一没有解决的一道题，今在 Gemini 老师的帮助下成功解决，决定重写一份题解报告。\nDescription 题目传送门\n题目要求参赛者优化一个 C 语言函数 rotate_the_bit_vector，函数功能是对一个 bit vector 中的一个指定子区间进行循环旋转操作。\n具体而言，题目给的 bit_vector 是一种内存紧凑的数据结构，将 8 个 bit 打包存储到一个字节中。参赛者需要在只修改 submit_func.c 一个文件的前提下重写其中的 rotate_the_bit_vector 函数，使其在大规模数据时尽可能快。\n最后评分程序会通过三个不同的 benchmark (-s, -m, -l) 来衡量，每个测试中的数据规模会随着层数的增加而几何级增长，最终的得分取决于规定时间内能到达的“层数”，层数越高。说明性能越好，最终分数也越高。\nAnalysis Three-Reversal Algorithm 假设要移动的区间长度为 $ n $ ，需要移动 $ k $ 位；由于向右旋转 $ k $ 位可以等效于向左旋转 $ n-k $ 位，因此只讨论向左的移动。\n题目提供了一个初始的性能极差的实现，通过逐位移动 $ k $ 次来实现 $ k $ 位循环旋转，复杂度为 $ O(n^{2}) $。根据这个原始实现很容易想到一个初步的优化方案：\n问题的核心是把数组 [A|B] 变成 [B|A] ，一个经典的算法是三步翻转法：如果我们把翻转操作记为 ' ，A' 表示数组 A 前后反转，那么可以发现原问题的操作实际上等价于三次翻转操作：[A'|B']' = [B|A] ，复杂度为 $ O(n) $ ，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \"./bit_vector.h\" #include #include #include static void reverse_bits(bit_vector_t* const bit_vector, size_t start, size_t end) { while (start \u003c end) { bool temp = bit_vector_get(bit_vector, start); bit_vector_set(bit_vector, start, bit_vector_get(bit_vector, end)); bit_vector_set(bit_vector, end, temp); start++; end--; } } static size_t modulo(const ssize_t n, const size_t m) { const ssize_t signed_m = (ssize_t)m; assert(signed_m \u003e 0); const ssize_t result = ((n % signed_m) + signed_m) % signed_m; assert(result \u003e= 0); return (size_t)result; } void rotate_the_bit_vector(bit_vector_t* const bit_vector, const size_t bit_offset, const size_t bit_length, const ssize_t bit_right_amount) { assert(bit_offset + bit_length \u003c= bit_vector_get_bit_sz(bit_vector)); if (bit_length \u003c= 1) { return; } size_t left_shift = modulo(-bit_right_amount, bit_length); if (left_shift == 0) { return; } // 1. reverse [0, left_shift - 1] reverse_bits(bit_vector, bit_offset, bit_offset + left_shift - 1); // 2. reverse [left_shift, bit_length - 1] reverse_bits(bit_vector, bit_offset + left_shift, bit_offset + bit_length - 1); // 3. reverse [0, bit_length - 1] reverse_bits(bit_vector, bit_offset, bit_offset + bit_length - 1); } 运行测试程序发现只能得到 72 pts\n1 2 3 4 5 6 7 8 9 check result: PASSED performance of -s: 26 performance of -m: 32 performance of -l: 37 ------score-------- -s : 60.00 /100 -m : 72.73 /100 -l : 76.00 /100 total score: 71.82 /100 Performance Analysis with perf 根据题目的提示，我们应该使用 perf 工具来分析性能的瓶颈：\n1 perf record ./everybit -s 运行结束之后生成了一个名为 perf.data 的文件，之后再运行指令分析报告\n1 perf report 输出的交互式界面显示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Overhead Command Shared Object Symbol 47.99% everybit everybit [.] bit_vector_set 20.29% everybit everybit [.] bit_vector_get 16.12% everybit everybit [.] bitmask 11.66% everybit everybit [.] reverse_bits 3.26% everybit libc.so.6 [.] __random 0.15% everybit libc.so.6 [.] rand 0.08% everybit [vdso] [.] __vdso_clock_gettime 0.08% everybit everybit [.] bit_vector_randfill 0.08% everybit ld-linux-x86-64.so.2 [.] _dl_init_paths 0.08% everybit ld-linux-x86-64.so.2 [.] handle_intel.constprop.0 0.08% everybit libc.so.6 [.] __random_r 0.08% everybit libc.so.6 [.] _int_free 0.08% everybit libc.so.6 [.] memmove 发现主要的性能瓶颈在 bit_vector_set 和 bit_vector_get 两个操作，这表明虽然我们的算法本身高效，但是其性能严重依赖这两个效率低下的 API ，这指出了我们的下一步优化方向就是这两个操作本身，任何不绕开这两个函数的优化都是治标不治本。\nSpace-for-Time 既然瓶颈在于逐位操作，那么优化的核心思想必然是用块级操作替代位级操作。因此我们需要放弃之前翻转的做法，因为这必然会涉及到位级操作。\n作为替代，我们很自然有用空间换时间的想法：\n在堆上用 malloc 开辟一块足够大的临时缓冲区 temp_buffer。 将原数组需要旋转的 B 和 A 两部分，依次拷贝到 temp_buffer 中，使其内容直接变成旋转后的 [B|A] 顺序。 将 temp_buffer 的内容一次性拷贝回原数组。 由于操作区间是非字节对齐的，我们不能直接使用 memcpy。因此，问题的关键就变成了实现一个高性能、支持任意比特偏移的 bithack_memcpy 函数。\n按照这个思路优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include \"./bit_vector.h\" #include #include #include #include #include // alloca.h is no longer needed for the final version // #include #include /** * @brief A highly optimized bit-level memcpy. * * Copies 'bit_len' bits from a source buffer at a given bit offset to a * destination buffer at another bit offset. This function is the core of the * performance optimization, using 64-bit word operations for the bulk of the copy. * * @param dst_buf The destination memory buffer. * @param dst_offset The starting bit offset in the destination buffer. * @param src_buf The source memory buffer. * @param src_offset The starting bit offset in the source buffer. * @param bit_len The number of bits to copy. */ static void bithack_memcpy(char* dst_buf, size_t dst_offset, const char* src_buf, size_t src_offset, size_t bit_len) { if (bit_len == 0) { return; } size_t bits_copied = 0; // Handle the head: copy bit by bit until the destination is byte-aligned. int head_bits = (8 - (dst_offset % 8)) % 8; if (head_bits \u003e bit_len) { head_bits = bit_len; } for (int i = 0; i \u003c head_bits; i++) { if ((src_buf[(src_offset + i) / 8] \u003e\u003e ((src_offset + i) % 8)) \u0026 1) dst_buf[(dst_offset + i) / 8] |= (1 \u003c\u003c ((dst_offset + i) % 8)); else dst_buf[(dst_offset + i) / 8] \u0026= ~(1 \u003c\u003c ((dst_offset + i) % 8)); } bits_copied += head_bits; // Handle the middle: use 64-bit word operations for maximum speed. while (bit_len - bits_copied \u003e= 64) { size_t current_src_offset = src_offset + bits_copied; size_t current_dst_offset = dst_offset + bits_copied; uint64_t src_word; memcpy(\u0026src_word, src_buf + current_src_offset / 8, sizeof(src_word)); int bit_shift = current_src_offset % 8; if (bit_shift != 0) { uint8_t next_byte = src_buf[current_src_offset / 8 + 8]; src_word = (src_word \u003e\u003e bit_shift) | (((uint64_t)next_byte) \u003c\u003c (64 - bit_shift)); } memcpy(dst_buf + current_dst_offset / 8, \u0026src_word, sizeof(src_word)); bits_copied += 64; } // Handle the tail: copy the remaining bits one by one. for (size_t i = bits_copied; i \u003c bit_len; i++) { if ((src_buf[(src_offset + i) / 8] \u003e\u003e ((src_offset + i) % 8)) \u0026 1) dst_buf[(dst_offset + i) / 8] |= (1 \u003c\u003c ((dst_offset + i) % 8)); else dst_buf[(dst_offset + i) / 8] \u0026= ~(1 \u003c\u003c ((dst_offset + i) % 8)); } } static size_t modulo(const ssize_t n, const size_t m) { const ssize_t signed_m = (ssize_t)m; assert(signed_m \u003e 0); const ssize_t result = ((n % signed_m) + signed_m) % signed_m; assert(result \u003e= 0); return (size_t)result; } void rotate_the_bit_vector(bit_vector_t* const bit_vector, const size_t bit_offset, const size_t bit_length, const ssize_t bit_right_amount) { assert(bit_offset + bit_length \u003c= bit_vector_get_bit_sz(bit_vector)); if (bit_length \u003c= 1) { return; } size_t left_shift = modulo(-bit_right_amount, bit_length); if (left_shift == 0) { return; } size_t buf_byte_size = (bit_length + 7) / 8; char* temp_buffer = (char*)malloc(buf_byte_size); if (temp_buffer == NULL) { exit(1); } size_t first_part_len = bit_length - left_shift; size_t second_part_len = left_shift; bithack_memcpy(temp_buffer, 0, bit_vector-\u003ebuf, bit_offset + left_shift, first_part_len); bithack_memcpy(temp_buffer, first_part_len, bit_vector-\u003ebuf, bit_offset, second_part_len); bithack_memcpy(bit_vector-\u003ebuf, bit_offset, temp_buffer, 0, bit_length); free(temp_buffer); } 现在可以完美获得满分：\n1 2 3 4 5 6 7 8 9 check result: PASSED performance of -s: 37 performance of -m: 40 performance of -l: 44 ------score-------- -s : 100.00 /100 -m : 100.00 /100 -l : 100.00 /100 total score: 100.00 /100 250918 upd: 稍微优化一下 middle 循环中的除法和取模操作，可以再提高一些性能。\nDetails 最终的满分代码完全围绕 bithack_memcpy 函数构建。其工作原理的关键在于分块处理和对底层硬件原理的理解。\n函数将任意拷贝任务拆分为三段：Head , Middle 和 Tail。Head 部分通过逐位拷贝，其唯一目的是让接下来的目标地址实现字节对齐。Tail 部分则处理最后剩下的、不足一个块的零散比特。\n性能优化的核心在 Middle 部分，它以 64 位（8 字节）为单位进行块拷贝。其中处理非对齐源数据的逻辑是精髓所在：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 uint64_t src_word; // 1. 预读取：从源地址的字节边界开始，安全地读取8个字节。 // 这导致我们拿到的数据相对于真正的起始点有一个偏移。 memcpy(\u0026src_word, src_buf + current_src_offset / 8, sizeof(src_word)); int bit_shift = current_src_offset % 8; if (bit_shift != 0) { // 2. 抓取：读取紧邻的下一个字节，它包含了我们缺失的数据。 uint8_t next_byte = src_buf[current_src_offset / 8 + 8]; // 3. 移位与拼接： // a. (src_word \u003e\u003e bit_shift): 将预读取的数据右移，丢弃头部多余的比特。 // b. (((uint64_t)next_byte) \u003c\u003c (64 - bit_shift)): // 将下一个字节左移，使其恰好能填充右移后在高位留下的空缺。 // c. | : 通过或运算，将两部分拼接，重组出我们真正需要的64个比特。 src_word = (src_word \u003e\u003e bit_shift) | (((uint64_t)next_byte) \u003c\u003c (64 - bit_shift)); } // 4. 写入：因为目标地址已对齐，所以可以高效地将重组好的 64 位数据写入。 memcpy(dst_buf + current_dst_offset / 8, \u0026src_word, sizeof(src_word)); 其高性能的根源在于两个核心的底层原理：内存对齐 (Data Alignment) 与 数据局部性 (Data Locality)。\nData Alignment：CPU 访问内存以“字”（Word，64 位 CPU 即 8 字节）为单位。如果数据地址是其大小的倍数，CPU 就能一次内存事务完成读写，这叫对齐访问。非对齐访问则可能需要两次内存事务和内部拼接，性能大幅下降。bithack_memcpy 的“头部处理”阶段，其唯一目的就是实现目标地址的字节对齐，确保占主导地位的中部循环可以执行最高效的对齐写入操作。\nMemory Locality \u0026 Caching：CPU 内部有多级 Cache，速度远快于 RAM。当 CPU 访问某块内存时，会把其邻近的一整个 Cache Line 都预加载到缓存中。这就是空间局部性原理 (Principle of Spatial Locality)。我们的 bithack_memcpy 函数利用了这一点，无论是从原数组读，还是在临时缓冲区里读写，操作的都是连续的大块内存。当循环处理第一个 64 位字时，CPU 很可能已经将后面几百个字节的数据预加载到了的 L1 Cache 中，后续迭代无需访问慢速的内存，缓存命中率 (Cache Hit Rate) 极高。相比之下，最初的三步翻转法在内存中“来回跳跃”地访问单个比特，破坏了空间局部性，导致缓存命中率极低，性能自然不佳。\n在开辟缓冲区的选择上面，笔者一开始选择了 alloc ，相比于堆内存，栈内存更快且不需要手动释放，但是发现在测试到一定的层数之后就会由于数据量过大而出现 Segment Falut ，因此最后还是选择了使用 malloc 来分配缓冲区。\n","wordCount":"1306","inLanguage":"en","image":"https://diefish1024.github.io/images/avatar.jpg","datePublished":"2025-09-02T16:15:00+08:00","dateModified":"2025-09-02T16:15:00+08:00","author":{"@type":"Person","name":"diefish"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://diefish1024.github.io/posts/solutions/xflops2024-bithack/"},"publisher":{"@type":"Organization","name":"diefish's blog","logo":{"@type":"ImageObject","url":"https://diefish1024.github.io/images/avatar.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://diefish1024.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://diefish1024.github.io/images/avatar.jpg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://diefish1024.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://diefish1024.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://diefish1024.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://diefish1024.github.io/search/ title=Search><span>Search</span></a></li><li><a href=https://diefish1024.github.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://diefish1024.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://diefish1024.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://diefish1024.github.io/posts/solutions/>Solutions</a></div><h1 class="post-title entry-hint-parent">Xflops2024-Bithack</h1><div class=post-meta><span title='2025-09-02 16:15:00 +0800 +0800'>September 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;diefish&nbsp;|&nbsp;<a href=https://github.com/diefish1024/diefish1024.github.io/blob/main/content/posts/Solutions/xflops2024-bithack.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#description aria-label=Description>Description</a></li><li><a href=#analysis aria-label=Analysis>Analysis</a><ul><li><a href=#three-reversal-algorithm aria-label="Three-Reversal Algorithm">Three-Reversal Algorithm</a></li><li><a href=#performance-analysis-with-perf aria-label="Performance Analysis with perf">Performance Analysis with perf</a></li><li><a href=#space-for-time aria-label=Space-for-Time>Space-for-Time</a></li></ul></li><li><a href=#details aria-label=Details>Details</a></li></ul></div></details></div><div class=post-content><p>去年超算队招新唯一没有解决的一道题，今在 Gemini 老师的帮助下成功解决，决定重写一份题解报告。</p><h2 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h2><p><a href=https://github.com/HPC-SJTU/Xflops2024_1st_exam/tree/main/Bithack>题目传送门</a></p><p>题目要求参赛者优化一个 C 语言函数 <code>rotate_the_bit_vector</code>，函数功能是对一个 bit vector 中的一个指定子区间进行<strong>循环旋转</strong>操作。</p><p>具体而言，题目给的 <code>bit_vector</code> 是一种内存紧凑的数据结构，将 8 个 bit 打包存储到一个字节中。参赛者需要在只修改 <code>submit_func.c</code> 一个文件的前提下重写其中的 <code>rotate_the_bit_vector</code> 函数，使其在大规模数据时尽可能快。</p><p>最后评分程序会通过三个不同的 benchmark (<code>-s</code>, <code>-m</code>, <code>-l</code>) 来衡量，每个测试中的数据规模会随着层数的增加而几何级增长，最终的得分取决于规定时间内能到达的“层数”，层数越高。说明性能越好，最终分数也越高。</p><h2 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h2><h3 id=three-reversal-algorithm>Three-Reversal Algorithm<a hidden class=anchor aria-hidden=true href=#three-reversal-algorithm>#</a></h3><p>假设要移动的区间长度为 $ n $ ，需要移动 $ k $ 位；由于向右旋转 $ k $ 位可以等效于向左旋转 $ n-k $ 位，因此只讨论向左的移动。</p><p>题目提供了一个初始的性能极差的实现，通过逐位移动 $ k $ 次来实现 $ k $ 位循环旋转，复杂度为 $ O(n^{2}) $。根据这个原始实现很容易想到一个初步的优化方案：</p><p>问题的核心是把数组 <code>[A|B]</code> 变成 <code>[B|A]</code> ，一个经典的算法是<strong>三步翻转法</strong>：如果我们把翻转操作记为 <code>'</code> ，<code>A'</code> 表示数组 <code>A</code> 前后反转，那么可以发现原问题的操作实际上等价于三次翻转操作：<code>[A'|B']' = [B|A]</code> ，复杂度为 $ O(n) $ ，代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;./bit_vector.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdbool.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>reverse_bits</span><span class=p>(</span><span class=n>bit_vector_t</span><span class=o>*</span> <span class=k>const</span> <span class=n>bit_vector</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>start</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>start</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>bit_vector_get</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>,</span> <span class=n>start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>bit_vector_set</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>bit_vector_get</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>,</span> <span class=n>end</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>bit_vector_set</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>start</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>end</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>size_t</span> <span class=nf>modulo</span><span class=p>(</span><span class=k>const</span> <span class=n>ssize_t</span> <span class=n>n</span><span class=p>,</span> <span class=k>const</span> <span class=n>size_t</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>ssize_t</span> <span class=n>signed_m</span> <span class=o>=</span> <span class=p>(</span><span class=n>ssize_t</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>signed_m</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>ssize_t</span> <span class=n>result</span> <span class=o>=</span> <span class=p>((</span><span class=n>n</span> <span class=o>%</span> <span class=n>signed_m</span><span class=p>)</span> <span class=o>+</span> <span class=n>signed_m</span><span class=p>)</span> <span class=o>%</span> <span class=n>signed_m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>result</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span><span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rotate_the_bit_vector</span><span class=p>(</span><span class=n>bit_vector_t</span><span class=o>*</span> <span class=k>const</span> <span class=n>bit_vector</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>const</span> <span class=n>size_t</span> <span class=n>bit_offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>const</span> <span class=n>size_t</span> <span class=n>bit_length</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>const</span> <span class=n>ssize_t</span> <span class=n>bit_right_amount</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>bit_offset</span> <span class=o>+</span> <span class=n>bit_length</span> <span class=o>&lt;=</span> <span class=n>bit_vector_get_bit_sz</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bit_length</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>left_shift</span> <span class=o>=</span> <span class=n>modulo</span><span class=p>(</span><span class=o>-</span><span class=n>bit_right_amount</span><span class=p>,</span> <span class=n>bit_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>left_shift</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. reverse [0, left_shift - 1]
</span></span></span><span class=line><span class=cl>    <span class=n>reverse_bits</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>,</span> <span class=n>bit_offset</span><span class=p>,</span> <span class=n>bit_offset</span> <span class=o>+</span> <span class=n>left_shift</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 2. reverse [left_shift, bit_length - 1]
</span></span></span><span class=line><span class=cl>    <span class=n>reverse_bits</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>,</span> <span class=n>bit_offset</span> <span class=o>+</span> <span class=n>left_shift</span><span class=p>,</span> <span class=n>bit_offset</span> <span class=o>+</span> <span class=n>bit_length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. reverse [0, bit_length - 1]
</span></span></span><span class=line><span class=cl>    <span class=n>reverse_bits</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>,</span> <span class=n>bit_offset</span><span class=p>,</span> <span class=n>bit_offset</span> <span class=o>+</span> <span class=n>bit_length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>运行测试程序发现只能得到 72 pts</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>check result: PASSED
</span></span><span class=line><span class=cl>performance of -s: 26
</span></span><span class=line><span class=cl>performance of -m: 32
</span></span><span class=line><span class=cl>performance of -l: 37
</span></span><span class=line><span class=cl>------score--------
</span></span><span class=line><span class=cl>-s : 60.00 /100
</span></span><span class=line><span class=cl>-m : 72.73 /100
</span></span><span class=line><span class=cl>-l : 76.00 /100
</span></span><span class=line><span class=cl>total score: 71.82 /100
</span></span></code></pre></td></tr></table></div></div><h3 id=performance-analysis-with-perf>Performance Analysis with <code>perf</code><a hidden class=anchor aria-hidden=true href=#performance-analysis-with-perf>#</a></h3><p>根据题目的提示，我们应该使用 <code>perf</code> 工具来分析性能的瓶颈：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>perf record ./everybit -s
</span></span></code></pre></td></tr></table></div></div><p>运行结束之后生成了一个名为 <code>perf.data</code> 的文件，之后再运行指令分析报告</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>perf report
</span></span></code></pre></td></tr></table></div></div><p>输出的交互式界面显示</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>Overhead</span>  <span class=n>Command</span>   <span class=n>Shared</span> <span class=ne>Object</span>         <span class=n>Symbol</span>
</span></span><span class=line><span class=cl>  <span class=mf>47.99</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>everybit</span>              <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>bit_vector_set</span>
</span></span><span class=line><span class=cl>  <span class=mf>20.29</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>everybit</span>              <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>bit_vector_get</span>
</span></span><span class=line><span class=cl>  <span class=mf>16.12</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>everybit</span>              <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>bitmask</span>
</span></span><span class=line><span class=cl>  <span class=mf>11.66</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>everybit</span>              <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>reverse_bits</span>
</span></span><span class=line><span class=cl>   <span class=mf>3.26</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>libc</span><span class=o>.</span><span class=n>so</span><span class=o>.</span><span class=mi>6</span>             <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>__random</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.15</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>libc</span><span class=o>.</span><span class=n>so</span><span class=o>.</span><span class=mi>6</span>             <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>rand</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.08</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=p>[</span><span class=n>vdso</span><span class=p>]</span>                <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>__vdso_clock_gettime</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.08</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>everybit</span>              <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>bit_vector_randfill</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.08</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>ld</span><span class=o>-</span><span class=n>linux</span><span class=o>-</span><span class=n>x86</span><span class=o>-</span><span class=mf>64.</span><span class=n>so</span><span class=o>.</span><span class=mi>2</span>  <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>_dl_init_paths</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.08</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>ld</span><span class=o>-</span><span class=n>linux</span><span class=o>-</span><span class=n>x86</span><span class=o>-</span><span class=mf>64.</span><span class=n>so</span><span class=o>.</span><span class=mi>2</span>  <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>handle_intel</span><span class=o>.</span><span class=n>constprop</span><span class=o>.</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.08</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>libc</span><span class=o>.</span><span class=n>so</span><span class=o>.</span><span class=mi>6</span>             <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>__random_r</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.08</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>libc</span><span class=o>.</span><span class=n>so</span><span class=o>.</span><span class=mi>6</span>             <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>_int_free</span>
</span></span><span class=line><span class=cl>   <span class=mf>0.08</span><span class=o>%</span>  <span class=n>everybit</span>  <span class=n>libc</span><span class=o>.</span><span class=n>so</span><span class=o>.</span><span class=mi>6</span>             <span class=p>[</span><span class=o>.</span><span class=p>]</span> <span class=n>memmove</span>
</span></span></code></pre></td></tr></table></div></div><p>发现主要的性能瓶颈在 <code>bit_vector_set</code> 和 <code>bit_vector_get</code> 两个操作，这表明虽然我们的算法本身高效，但是其性能严重依赖这两个效率低下的 API ，这指出了我们的下一步优化方向就是这两个操作本身，任何不绕开这两个函数的优化都是治标不治本。</p><h3 id=space-for-time>Space-for-Time<a hidden class=anchor aria-hidden=true href=#space-for-time>#</a></h3><p>既然瓶颈在于逐位操作，那么优化的核心思想必然是<strong>用块级操作替代位级操作</strong>。因此我们需要放弃之前翻转的做法，因为这必然会涉及到位级操作。</p><p>作为替代，我们很自然有<strong>用空间换时间</strong>的想法：</p><ol><li>在堆上用 <code>malloc</code> 开辟一块足够大的临时缓冲区 <code>temp_buffer</code>。</li><li>将原数组需要旋转的 <code>B</code> 和 <code>A</code> 两部分，依次拷贝到 <code>temp_buffer</code> 中，使其内容直接变成旋转后的 <code>[B|A]</code> 顺序。</li><li>将 <code>temp_buffer</code> 的内容一次性拷贝回原数组。</li></ol><p>由于操作区间是非字节对齐的，我们不能直接使用 <code>memcpy</code>。因此，问题的关键就变成了实现一个高性能、支持任意比特偏移的 <code>bithack_memcpy</code> 函数。</p><p>按照这个思路优化后的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;./bit_vector.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdbool.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=c1>// alloca.h is no longer needed for the final version
</span></span></span><span class=line><span class=cl><span class=c1>// #include &lt;alloca.h&gt; 
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * @brief A highly optimized bit-level memcpy.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Copies &#39;bit_len&#39; bits from a source buffer at a given bit offset to a
</span></span></span><span class=line><span class=cl><span class=cm> * destination buffer at another bit offset. This function is the core of the
</span></span></span><span class=line><span class=cl><span class=cm> * performance optimization, using 64-bit word operations for the bulk of the copy.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param dst_buf The destination memory buffer.
</span></span></span><span class=line><span class=cl><span class=cm> * @param dst_offset The starting bit offset in the destination buffer.
</span></span></span><span class=line><span class=cl><span class=cm> * @param src_buf The source memory buffer.
</span></span></span><span class=line><span class=cl><span class=cm> * @param src_offset The starting bit offset in the source buffer.
</span></span></span><span class=line><span class=cl><span class=cm> * @param bit_len The number of bits to copy.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>bithack_memcpy</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>dst_buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>dst_offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>src_buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>src_offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>size_t</span> <span class=n>bit_len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bit_len</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>bits_copied</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle the head: copy bit by bit until the destination is byte-aligned.
</span></span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>head_bits</span> <span class=o>=</span> <span class=p>(</span><span class=mi>8</span> <span class=o>-</span> <span class=p>(</span><span class=n>dst_offset</span> <span class=o>%</span> <span class=mi>8</span><span class=p>))</span> <span class=o>%</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>head_bits</span> <span class=o>&gt;</span> <span class=n>bit_len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>head_bits</span> <span class=o>=</span> <span class=n>bit_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>head_bits</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>src_buf</span><span class=p>[(</span><span class=n>src_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span><span class=p>]</span> <span class=o>&gt;&gt;</span> <span class=p>((</span><span class=n>src_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=mi>8</span><span class=p>))</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>dst_buf</span><span class=p>[(</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span><span class=p>]</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>dst_buf</span><span class=p>[(</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span><span class=p>]</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>bits_copied</span> <span class=o>+=</span> <span class=n>head_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle the middle: use 64-bit word operations for maximum speed.
</span></span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>bit_len</span> <span class=o>-</span> <span class=n>bits_copied</span> <span class=o>&gt;=</span> <span class=mi>64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>current_src_offset</span> <span class=o>=</span> <span class=n>src_offset</span> <span class=o>+</span> <span class=n>bits_copied</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>current_dst_offset</span> <span class=o>=</span> <span class=n>dst_offset</span> <span class=o>+</span> <span class=n>bits_copied</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>src_word</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>src_word</span><span class=p>,</span> <span class=n>src_buf</span> <span class=o>+</span> <span class=n>current_src_offset</span> <span class=o>/</span> <span class=mi>8</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>src_word</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>bit_shift</span> <span class=o>=</span> <span class=n>current_src_offset</span> <span class=o>%</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>bit_shift</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint8_t</span> <span class=n>next_byte</span> <span class=o>=</span> <span class=n>src_buf</span><span class=p>[</span><span class=n>current_src_offset</span> <span class=o>/</span> <span class=mi>8</span> <span class=o>+</span> <span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>src_word</span> <span class=o>=</span> <span class=p>(</span><span class=n>src_word</span> <span class=o>&gt;&gt;</span> <span class=n>bit_shift</span><span class=p>)</span> <span class=o>|</span> <span class=p>(((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>next_byte</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>64</span> <span class=o>-</span> <span class=n>bit_shift</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=n>dst_buf</span> <span class=o>+</span> <span class=n>current_dst_offset</span> <span class=o>/</span> <span class=mi>8</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>src_word</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>src_word</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>bits_copied</span> <span class=o>+=</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle the tail: copy the remaining bits one by one.
</span></span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=n>bits_copied</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>bit_len</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>src_buf</span><span class=p>[(</span><span class=n>src_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span><span class=p>]</span> <span class=o>&gt;&gt;</span> <span class=p>((</span><span class=n>src_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=mi>8</span><span class=p>))</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>dst_buf</span><span class=p>[(</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span><span class=p>]</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>dst_buf</span><span class=p>[(</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span><span class=p>]</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=n>dst_offset</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>size_t</span> <span class=nf>modulo</span><span class=p>(</span><span class=k>const</span> <span class=n>ssize_t</span> <span class=n>n</span><span class=p>,</span> <span class=k>const</span> <span class=n>size_t</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>ssize_t</span> <span class=n>signed_m</span> <span class=o>=</span> <span class=p>(</span><span class=n>ssize_t</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>signed_m</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>ssize_t</span> <span class=n>result</span> <span class=o>=</span> <span class=p>((</span><span class=n>n</span> <span class=o>%</span> <span class=n>signed_m</span><span class=p>)</span> <span class=o>+</span> <span class=n>signed_m</span><span class=p>)</span> <span class=o>%</span> <span class=n>signed_m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>result</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span><span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rotate_the_bit_vector</span><span class=p>(</span><span class=n>bit_vector_t</span><span class=o>*</span> <span class=k>const</span> <span class=n>bit_vector</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>const</span> <span class=n>size_t</span> <span class=n>bit_offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>const</span> <span class=n>size_t</span> <span class=n>bit_length</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>const</span> <span class=n>ssize_t</span> <span class=n>bit_right_amount</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>bit_offset</span> <span class=o>+</span> <span class=n>bit_length</span> <span class=o>&lt;=</span> <span class=n>bit_vector_get_bit_sz</span><span class=p>(</span><span class=n>bit_vector</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bit_length</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>left_shift</span> <span class=o>=</span> <span class=n>modulo</span><span class=p>(</span><span class=o>-</span><span class=n>bit_right_amount</span><span class=p>,</span> <span class=n>bit_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>left_shift</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>buf_byte_size</span> <span class=o>=</span> <span class=p>(</span><span class=n>bit_length</span> <span class=o>+</span> <span class=mi>7</span><span class=p>)</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>temp_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>buf_byte_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>temp_buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>first_part_len</span> <span class=o>=</span> <span class=n>bit_length</span> <span class=o>-</span> <span class=n>left_shift</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>second_part_len</span> <span class=o>=</span> <span class=n>left_shift</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>bithack_memcpy</span><span class=p>(</span><span class=n>temp_buffer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>bit_vector</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>,</span> <span class=n>bit_offset</span> <span class=o>+</span> <span class=n>left_shift</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>first_part_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>bithack_memcpy</span><span class=p>(</span><span class=n>temp_buffer</span><span class=p>,</span> <span class=n>first_part_len</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>bit_vector</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>,</span> <span class=n>bit_offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>second_part_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>bithack_memcpy</span><span class=p>(</span><span class=n>bit_vector</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>,</span> <span class=n>bit_offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>temp_buffer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>bit_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>temp_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>现在可以完美获得满分：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>check result: PASSED
</span></span><span class=line><span class=cl>performance of -s: 37
</span></span><span class=line><span class=cl>performance of -m: 40
</span></span><span class=line><span class=cl>performance of -l: 44
</span></span><span class=line><span class=cl>------score--------
</span></span><span class=line><span class=cl>-s : 100.00 /100
</span></span><span class=line><span class=cl>-m : 100.00 /100
</span></span><span class=line><span class=cl>-l : 100.00 /100
</span></span><span class=line><span class=cl>total score: 100.00 /100
</span></span></code></pre></td></tr></table></div></div><p>250918 upd: 稍微优化一下 middle 循环中的除法和取模操作，可以再提高一些性能。</p><h2 id=details>Details<a hidden class=anchor aria-hidden=true href=#details>#</a></h2><p>最终的满分代码完全围绕 <code>bithack_memcpy</code> 函数构建。其工作原理的关键在于<strong>分块处理</strong>和对底层硬件原理的理解。</p><p>函数将任意拷贝任务拆分为三段：<code>Head</code> , <code>Middle</code> 和 <code>Tail</code>。<code>Head</code> 部分通过逐位拷贝，其唯一目的是让接下来的<strong>目标地址实现字节对齐</strong>。<code>Tail</code> 部分则处理最后剩下的、不足一个块的零散比特。</p><p>性能优化的核心在 <code>Middle</code> 部分，它以 64 位（8 字节）为单位进行块拷贝。其中处理非对齐源数据的逻辑是精髓所在：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=n>src_word</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 1. 预读取：从源地址的字节边界开始，安全地读取8个字节。
</span></span></span><span class=line><span class=cl><span class=c1>// 这导致我们拿到的数据相对于真正的起始点有一个偏移。
</span></span></span><span class=line><span class=cl><span class=nf>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>src_word</span><span class=p>,</span> <span class=n>src_buf</span> <span class=o>+</span> <span class=n>current_src_offset</span> <span class=o>/</span> <span class=mi>8</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>src_word</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>bit_shift</span> <span class=o>=</span> <span class=n>current_src_offset</span> <span class=o>%</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>bit_shift</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 抓取：读取紧邻的下一个字节，它包含了我们缺失的数据。
</span></span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>next_byte</span> <span class=o>=</span> <span class=n>src_buf</span><span class=p>[</span><span class=n>current_src_offset</span> <span class=o>/</span> <span class=mi>8</span> <span class=o>+</span> <span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 移位与拼接：
</span></span></span><span class=line><span class=cl>    <span class=c1>//    a. (src_word &gt;&gt; bit_shift): 将预读取的数据右移，丢弃头部多余的比特。
</span></span></span><span class=line><span class=cl>    <span class=c1>//    b. (((uint64_t)next_byte) &lt;&lt; (64 - bit_shift)): 
</span></span></span><span class=line><span class=cl>    <span class=c1>//       将下一个字节左移，使其恰好能填充右移后在高位留下的空缺。
</span></span></span><span class=line><span class=cl>    <span class=c1>//    c. | : 通过或运算，将两部分拼接，重组出我们真正需要的64个比特。
</span></span></span><span class=line><span class=cl>    <span class=n>src_word</span> <span class=o>=</span> <span class=p>(</span><span class=n>src_word</span> <span class=o>&gt;&gt;</span> <span class=n>bit_shift</span><span class=p>)</span> <span class=o>|</span> <span class=p>(((</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>next_byte</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>64</span> <span class=o>-</span> <span class=n>bit_shift</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 4. 写入：因为目标地址已对齐，所以可以高效地将重组好的 64 位数据写入。
</span></span></span><span class=line><span class=cl><span class=nf>memcpy</span><span class=p>(</span><span class=n>dst_buf</span> <span class=o>+</span> <span class=n>current_dst_offset</span> <span class=o>/</span> <span class=mi>8</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>src_word</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>src_word</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p>其高性能的根源在于两个核心的底层原理：<strong>内存对齐 (Data Alignment)</strong> 与 <strong>数据局部性 (Data Locality)</strong>。</p><ul><li><p><strong>Data Alignment</strong>：CPU 访问内存以“字”（Word，64 位 CPU 即 8 字节）为单位。如果数据地址是其大小的倍数，CPU 就能<strong>一次内存事务</strong>完成读写，这叫<strong>对齐访问</strong>。非对齐访问则可能需要两次内存事务和内部拼接，性能大幅下降。<code>bithack_memcpy</code> 的“头部处理”阶段，其唯一目的就是<strong>实现目标地址的字节对齐</strong>，确保占主导地位的中部循环可以执行最高效的对齐写入操作。</p></li><li><p><strong>Memory Locality & Caching</strong>：CPU 内部有多级 Cache，速度远快于 RAM。当 CPU 访问某块内存时，会把其邻近的一整个 <strong>Cache Line</strong> 都预加载到缓存中。这就是<strong>空间局部性原理 (Principle of Spatial Locality)</strong>。我们的 <code>bithack_memcpy</code> 函数利用了这一点，无论是从原数组读，还是在临时缓冲区里读写，操作的都是<strong>连续的大块内存</strong>。当循环处理第一个 64 位字时，CPU 很可能已经将后面几百个字节的数据预加载到了的 L1 Cache 中，后续迭代无需访问慢速的内存，<strong>缓存命中率 (Cache Hit Rate)</strong> 极高。相比之下，最初的三步翻转法在内存中“来回跳跃”地访问单个比特，破坏了空间局部性，导致缓存命中率极低，性能自然不佳。</p></li></ul><p>在开辟缓冲区的选择上面，笔者一开始选择了 <code>alloc</code> ，相比于堆内存，栈内存更快且不需要手动释放，但是发现在测试到一定的层数之后就会由于数据量过大而出现 Segment Falut ，因此最后还是选择了使用 <code>malloc</code> 来分配缓冲区。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://diefish1024.github.io/tags/cs/>CS</a></li><li><a href=https://diefish1024.github.io/tags/hpc/>HPC</a></li><li><a href=https://diefish1024.github.io/tags/solution/>Solution</a></li></ul><nav class=paginav><a class=prev href=https://diefish1024.github.io/posts/hpc/%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98/><span class=title>« Prev</span><br><span>关于内存</span>
</a><a class=next href=https://diefish1024.github.io/posts/hpc/simd-%E5%85%A5%E9%97%A8/><span class=title>Next »</span><br><span>SIMD 入门</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Xflops2024-Bithack on x" href="https://x.com/intent/tweet/?text=Xflops2024-Bithack&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f&amp;hashtags=CS%2cHPC%2csolution"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Xflops2024-Bithack on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f&amp;title=Xflops2024-Bithack&amp;summary=Xflops2024-Bithack&amp;source=https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Xflops2024-Bithack on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f&title=Xflops2024-Bithack"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Xflops2024-Bithack on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Xflops2024-Bithack on whatsapp" href="https://api.whatsapp.com/send?text=Xflops2024-Bithack%20-%20https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Xflops2024-Bithack on telegram" href="https://telegram.me/share/url?text=Xflops2024-Bithack&amp;url=https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Xflops2024-Bithack on ycombinator" href="https://news.ycombinator.com/submitlink?t=Xflops2024-Bithack&u=https%3a%2f%2fdiefish1024.github.io%2fposts%2fsolutions%2fxflops2024-bithack%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://diefish1024.github.io/>diefish's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>