---
tags:
- learning
- CS
- nju-os
discipline: computer-science
publish: true
created: 2025-08-06 23:35
title: 22. 文件系统 API
categories:
- course-note
---
## 目录树

### 文件的抽象

操作系统将物理存储设备（如磁盘）的复杂性隐藏起来，提供了一个简单、统一的抽象——**文件**

文件可以看作是一个**虚拟的磁盘**，即一个命名的、一维的**字节序列**，支持 `read`, `write`, `lseek` 等操作

这种抽象使得上层应用无需关心数据在物理磁盘上的具体位置和存储方式

### 目录的引入

当文件数量增多时，需要一种方式来组织和管理它们

操作系统引入了**目录 (Directory)** 的概念，它是一种特殊的文件，其内容是其他文件或目录的列表

通过将文件和目录组织成一个层次化的**树状结构**，即**目录树**，可以方便地对文件进行分类、查找和管理

多数类 Unix 系统遵循 **FHS (Filesystem Hierarchy Standard)** 的目录结构约定，为软件和用户预测文件位置提供了便利

### 目录操作 API

操作系统提供了一系列系统调用来操作目录树，核心操作围绕“增删改查”
- `mkdir`: 创建一个新的目录
- `rmdir`: 删除一个空的目录
- `getdents`: 读取目录中的条目 (**d**irectory **ent**rie**s**)
- `link` / `unlink`: 创建或删除文件的链接

### 链接

链接是文件系统的一个重要特性，它允许一个文件拥有多个名字或存在于目录树的多个位置

链接主要分为两种类型：**硬链接**和**软链接（符号链接）**

#### 硬链接 Hard Link

**定义**：**硬链接**是让多个目录条目（文件名）直接指向磁盘上同一个**文件索引节点 (inode)**

每个文件在文件系统中都有一个唯一的 `inode`，它包含了文件的元数据（如权限、大小、数据块位置等）和数据本身

创建一个硬链接，相当于为同一个 `inode` 增加了一个新的入口点（文件名）

**特性**：
- 所有指向同一个 `inode` 的硬链接地位平等，没有主次之分
- `inode` 内部维护一个**链接计数 (reference count)**, 只有当这个计数减到 0 时，文件系统才会真正删除该 `inode` 和对应的数据块，这也是 `unlink` 系统调用的由来

**限制**：
 - 不能为目录创建硬链接，以防止在目录树中产生循环
 - 不能跨越不同的文件系统（因为 `inode` 号只在当前文件系统内唯一）

#### 软链接 Symbolic Link

**定义**：**软链接**，也称**符号链接 (symlink)**，是一个**特殊的文件**，它的内容是另一个文件或目录的**路径**

软链接本身拥有自己独立的 `inode` 和数据块，其数据块中存储的是一个文本字符串，即目标对象的路径名，当访问软链接时，操作系统会解析其内容，并将访问请求重定向到它所指向的路径

**特性**：
- **极其灵活**，因为它本质上只是一个路径的“快捷方式”
- 可以**链接到目录**
- 可以**跨越不同的文件系统**
- 可以创建一个“悬空”的链接 (**dangling link**)，即它指向的目标路径当前并不存在
- 删除软链接本身，对它指向的原始文件**没有任何影响**

**应用**:
- 常用于管理软件版本，例如让一个通用的命令（如 `python`）指向一个具体的版本文件（如 `/usr/bin/python3.9`）
- 被 **NixOS** 等系统用来构建高度可复现和隔离的环境，通过大量使用软链接将不同版本的软件包组合成一个虚拟的文件系统结构

## 文件的元数据

### 基本元数据

文件作为操作系统中的对象，拥有一系列的**属性 (attributes)**，这些属性就是**元数据 (metadata)**, 你可以通过 `ls -l` 命令查看文件的主要元数据，这包括文件的类型、所有者、大小、修改时间等关键信息

其中，**模式 (Mode)** 字段定义了文件的访问权限，它分为三组，分别对应**所有者 (owner)**、**所属组 (group)** 和**其他用户 (other)**，每组都包含读 (`r`)、写 (`w`)、执行 (`x`) 三种权限

一个常见的权限例子是 `755`，这是一个八进制数，常用于程序或目录
- 第一个 `7` 代表所有者权限, 7=4+2+1, 意味着**读、写、执行** (`rwx`) 权限全开
- 第二个 `5` 代表所属组权限, 5=4+0+1, 意味着**读、执行** (`r-x`) 权限
- 第三个 `5` 代表其他用户权限, 5=4+0+1, 同样是**读、执行** (`r-x`) 权限

### Extended Attributes (xattr)

**扩展属性 xattr** 是现代文件系统提供的一项强大功能，它允许为文件附加一个灵活的 **key-value** 键值对字典，用于存储标准元数据无法覆盖的任意信息，操作系统提供了 `fsetxattr` 和 `fgetxattr` 等系统调用来操作这些属性

**应用**：
- macOS 的**安全隔离**机制就是一个典型例子，当从网络下载文件后，系统会自动添加 `com.apple.quarantine` 属性，记录下载来源（URL）和时间，首次打开时，系统会检查此属性并向用户发出安全警告

- **文件内容元信息**: 应用程序可以利用 `xattr` 存储与文件内容相关的元信息，例如，图片浏览器可以存储照片的 **EXIF** 数据副本，或者音乐播放器可以存储歌曲的演唱者和专辑信息，便于管理和搜索；相比于文件目录只能按照文件标题索引，这种以内容作为索引才是现代文件系统更合理的做法

**缺陷**：虽然 `xattr` 功能强大，但它“好用不火”的原因在于其固有的缺陷

- **缺乏标准化与兼容性**: `xattr` 的**键名没有统一标准**，不同应用和系统间随意定义，导致数据难以互通，例如，`com.apple.quarantine` 属性在 Linux 或 Windows 上没有意义
- **工具支持不完善**: 许多经典的命令行工具，如 `cp`, `mv`, `tar`, `rsync` 等，**默认不会处理扩展属性**，在执行文件复制或打包时，这些重要的元数据可能会被**静默丢弃**，用户必须显式使用特定参数（如 `cp --preserve=xattr`, `rsync -X`）才能保留它们，这对依赖 `xattr` 的系统（如使用了 SELinux）可能是灾难性的
- **可见性低**: 扩展属性对于普通用户是**不可见的**，`ls -l` 命令并不会显示它们，需要使用 `getfattr` 或 `xattr -l` 等专用工具才能查看，这使得问题排查变得更加困难

### Access Control List (ACL)

传统的 `user/group/other` 权限模型在处理复杂的共享需求时显得力不从心，例如需要让用户 `bob` 访问 `alice` 的一个文件，但 `bob` 不在 `alice` 的用户组里，而又不想把文件权限开放给所有“其他用户”，**ACL** 就是为了解决这类问题而生的

ACL 提供了比传统模型**更精细、更灵活的访问控制机制**，它允许你为任意指定的用户或用户组设置独立的权限

## 文件系统级 API

与针对单个文件或目录的操作不同，文件系统还提供了一系列“系统级”的 API，用于管理整个文件系统的结构和行为

### 挂载 Mount

在类 Unix 系统中，所有的文件和目录都组织在一棵以根目录 `/` 为起点的巨大目录树下，而在 Windows 中，文件系统则分散在不同的“盘符”下（`C:`、`D:` 等）

**挂载 (mount)** 是构建这棵统一目录树的核心机制, 它的作用是将一个文件系统（通常来自一个独立的存储设备，如硬盘分区、U 盘或光盘）“附加”到现有目录树的一个**挂载点 (mount point)** 上, 挂载点是一个已存在的空目录

例如，命令 `mount /dev/sdb1 /mnt/data` 就将 `/dev/sdb1` 这个分区上的文件系统挂载到了 `/mnt/data` 目录, 此后，对 `/mnt/data` 目录内容的访问，实际上就是对 `/dev/sdb1` 分区根目录的访问, 整个 Linux 系统的根目录 `/` 本身也是在系统启动时挂载的第一个文件系统

### 回环设备 Loopback Device

`mount` 命令通常操作的是**块设备 (block device)**，但有时我们需要挂载一个存在于**文件**中的文件系统镜像（例如一个 `.iso` 光盘镜像文件）, 文件不是块设备，所以无法直接挂载

为了解决这个问题，Linux 提供了**回环设备 (loopback device)**, 这是一个虚拟的块设备，它不对应任何物理硬件，而是将一个普通文件作为其后端存储

它的工作流程可以想象成一个适配器： 
1. 将文件镜像与一个回环设备（如 `/dev/loop0`）关联起来, 这时，操作系统看待 `/dev/loop0` 就像看待一个真实的物理磁盘一样
2. 对这个回环设备执行 `mount` 操作，将其挂载到指定目录

这个过程的底层是通过 `ioctl` 系统调用实现的，它向 loop 驱动发送 `LOOP_SET_FD` 等命令，将文件描述符与一个空闲的 loop 设备进行绑定

### 联合文件系统 OverlayFS

OverlayFS 是一种强大的**联合文件系统 (UnionFS)**，它允许将多个不同的目录（称为层）“堆叠”起来，对外提供一个统一的、合并后的视图

我们可以用一个非常形象的比喻来理解它的工作原理：

- **底层 (`lowerdir`)**: 想象一张已经印刷好的、**不可修改的**原始画稿, 这就是只读的底层, 它可以有很多张，层层叠放
- **上层 (`upperdir`)**：在原始画稿上覆盖一张**透明的塑料薄膜**, 这就是可写的上层
- **合并视图 (merged view)**：你透过这张透明薄膜看到的最终景象，就是 OverlayFS 呈现给你的目录

基于这个模型，所有操作都变得非常直观：

- **读取文件**: 当你读取一个文件时，相当于透过透明薄膜看画稿, 如果文件只存在于底层，你会直接看到它, 如果文件在上层也存在，那么上层的版本会“遮盖”住底层的版本

- **修改文件**：你不能直接修改原始画稿（`lowerdir`），当你第一次尝试修改一个来自底层的文件时，系统会启动**写时复制 (Copy-on-Write)** 机制，先把这个文件从底层复制一份到上层的透明薄膜上，然后你所有的修改都发生在这份复制品上

- **创建文件**：这就像直接在透明薄膜上画新的内容，完全不影响下面的原始画稿

- **删除文件**：你无法擦除原始画稿的内容, 当你删除一个来自底层的文件时，系统会在上层创建一个特殊的“白点”文件 (**whiteout**)，像贴了一张不透明的小贴纸，刚好遮住底层的文件，让它看起来像是被删除了

这种分层和写时复制的机制是 **Docker** 等容器技术的核心, 容器镜像就是只读的 `lowerdir`，而每个运行的容器都有自己专属的可写 `upperdir`，这使得成百上千个容器可以共享同一个基础镜像，同时保持各自的隔离性，极大地节省了存储空间和部署时间

### 文件系统快照 Snapshot

一些高级的文件系统（如 `Btrfs`, `ZFS`）或逻辑卷管理器（LVM）支持**快照 (snapshot)** 功能，它可以在瞬间“冻结”并创建一个文件系统在某个时间点的完整副本

快照的实现也常常依赖于**写时复制**技术，创建快照时，并不会立即复制所有数据，而只是创建了一个指向当前数据块的指针集合, 当之后有数据块被修改时，文件系统不会覆盖旧的数据块，而是将修改写入新的位置，并让旧的快照指针继续指向未修改的旧数据块

这个功能对于系统备份、快速回滚和创建安全的测试环境非常有用
