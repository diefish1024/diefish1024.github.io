<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Math on diefish&#39;s blog</title>
    <link>https://diefish1024.github.io/tags/math/</link>
    <description>Recent content in Math on diefish&#39;s blog</description>
    <image>
      <title>diefish&#39;s blog</title>
      <url>https://diefish1024.github.io/images/avatar.jpg</url>
      <link>https://diefish1024.github.io/images/avatar.jpg</link>
    </image>
    <generator>Hugo -- 0.150.1</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 30 Sep 2025 16:12:00 +0800</lastBuildDate>
    <atom:link href="https://diefish1024.github.io/tags/math/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LA HW3</title>
      <link>https://diefish1024.github.io/posts/class-notes/math1205h-linear-algebra/la-hw3/</link>
      <pubDate>Tue, 30 Sep 2025 16:12:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/math1205h-linear-algebra/la-hw3/</guid>
      <description>&lt;h2 id=&#34;exercise-1&#34;&gt;Exercise 1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;(Multiplication of block matrices). Consider two block matrices
$$ 

 A = \begin{pmatrix}
 A_{11} &amp; \cdots &amp; A_{1t} \\
 \vdots &amp; \ddots &amp; \vdots \\
 A_{p1} &amp; \cdots &amp; A_{pt}
 \end{pmatrix}
 \quad \text{and} \quad
 B = \begin{pmatrix}
 B_{11} &amp; \cdots &amp; B_{1q} \\
 \vdots &amp; \ddots &amp; \vdots \\
 B_{t1} &amp; \cdots &amp; B_{tq}
 \end{pmatrix}
 
 $$
Moreover, for every $ i \in [p] $, $ j \in [t] $, and $ l \in [q] $ the number of columns of $ A_{ij} $ is equal to the number of rows of $ B_{jl} $. In particular, $ A_{ij} \cdot B_{jl} $ is defined. Prove that
$$ 

 A \cdot B = \begin{pmatrix}
 C_{11} &amp; \cdots &amp; C_{1q} \\
 \vdots &amp; \ddots &amp; \vdots \\
 C_{p1} &amp; \cdots &amp; C_{pq}
 \end{pmatrix}
 
 $$
with
$$ 

 C_{il} = \sum_{j \in [t]} A_{ij} B_{jl}
 
 $$
for any $ i \in [p] $ and $ l \in [q] $.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LA HW2</title>
      <link>https://diefish1024.github.io/posts/class-notes/math1205h-linear-algebra/la-hw2/</link>
      <pubDate>Mon, 29 Sep 2025 22:39:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/math1205h-linear-algebra/la-hw2/</guid>
      <description>&lt;h2 id=&#34;exercise-1&#34;&gt;Exercise 1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;What rows or columns or matrices do you multiply to find&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the second column of $ AB $ ?&lt;/li&gt;
&lt;li&gt;the first row of $ AB $ ?&lt;/li&gt;
&lt;li&gt;the entry in row $ 3 $, column $ 5 $ of $ AB $ ?&lt;/li&gt;
&lt;li&gt;the entry in row $ 1 $, column $ 1 $ of $ CDE $ ?&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To find the second column of $ AB $, we multiply matrix $ A $ by the second column of matrix $ B $.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Combinatorics HW2</title>
      <link>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/combinatorics-hw2/</link>
      <pubDate>Wed, 24 Sep 2025 20:50:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/combinatorics-hw2/</guid>
      <description>&lt;h2 id=&#34;problem-1&#34;&gt;Problem 1&lt;/h2&gt;
&lt;p&gt;用生成函数求解递推式
$$ 

a_{n} = 4a_{n-1} - 5a_{n-2} + 2a_{n-3}

 $$
初始值为 $ a_{0}=0,a_{1}=3,a_{2}=7 $。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;设数列 $ \{ a_{n} \} $ 的生成函数为 $ F(x) $，那么根据递推式和初值 $ a_{0}=0,a_{1}=3,a_{2}=7 $ 得到
$$ 

F(x) = 4xF(x) - 5x^{2}F(x) + 2x^{3}F(x) + 3x - 5x^{2}

 $$
得到
$$ 

F(x) = \dfrac{5x^{2}-3x}{2x^{3}-5x^{2}+4x-1} = \dfrac{3x-5x^{2}}{(1-x)^{2}(1-2x)}

 $$
我们希望分解成
$$ 

\dfrac{A}{1-x} + \dfrac{B}{(1-x)^{2}} + \dfrac{C}{1-2x}

 $$
待定系数可以解得
$$ 

F(x) = \dfrac{-3}{1-x} + \dfrac{2}{(1-x)^{2}} + \dfrac{1}{1-2x}

 $$
展开得到
$$ 

F(x) = \sum_{n=0}^{\infty} (-3+2(n+1)+2^{n})x^{n}

 $$
因此
$$ 

a_{n} = -3+2(n+1)+2^{n} = 2^{n} + 2n - 1

 $$&lt;/p&gt;</description>
    </item>
    <item>
      <title>LA HW1</title>
      <link>https://diefish1024.github.io/posts/class-notes/math1205h-linear-algebra/la-hw1/</link>
      <pubDate>Wed, 24 Sep 2025 12:55:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/math1205h-linear-algebra/la-hw1/</guid>
      <description>&lt;h2 id=&#34;exercise-1&#34;&gt;Exercise 1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Let $ f:\mathbb{R}\to\mathbb{R} $ be a function. Prove that the following are equivalent:
(i) There is a constant $ a\in\mathbb{R} $ such that for every$ x\in\mathbb{R} $ we have$ f(x)=ax $.
(ii) For all $ x_1,x_2,c,x\in\mathbb{R} $ we have $ f(x_1+x_2)=f(x_1)+f(x_2) $ and $ f(cx)=c\,f(x) $.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;(i ⇒ ii)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Assume there exists $ a\in\mathbb{R} $ such that $ f(x)=a x $ for all $ x\in\mathbb{R} $ . Then for any $ x_1,x_2,c,x\in\mathbb{R} $ ,&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lect2-Generating Functions</title>
      <link>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/lect2-generating-functions/</link>
      <pubDate>Tue, 23 Sep 2025 13:02:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/lect2-generating-functions/</guid>
      <description>&lt;p&gt;考虑上一节引入的二项式定理
$$ 

(1+x)^{n} = \sum_{k=0}^{n} \binom{ n }{ k } x^{k}

 $$
这可以理解成我们把二项系数转换成了一个函数，这使得我们能更有效地操作和分析序列，这个工具被成为&lt;strong&gt;生成函数&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ordinary-generating-functions&#34;&gt;Ordinary Generating Functions&lt;/h2&gt;
&lt;p&gt;给定序列 $ \{ a_{n} \}_{n\geq 0} $，由 $ \{ a_{n} \} $ 定义的&lt;strong&gt;普通生成函数 (OGF)&lt;/strong&gt; 为：
$$ 

G(x) = \sum_{n\geq  0} a_{n}x^{n}

 $$
虽然看起来 OGF 并没有被很好的定义，对于和某些数列，这个形式不会收敛，但是实际上生成函数并不能被看成一个真正的函数，它是一个&lt;strong&gt;形式幂级数&lt;/strong&gt;，并且不被要求收敛。&lt;/p&gt;
&lt;p&gt;以下是一些生成函数的基础例子：
$$ 

G(x) = 1+x+x^{2}+x^{3} +\dots = \dfrac{1}{1-x}

 $$
$$ 

G(x) = 1+ax+a^{2}x^{2} + a^{3}x^{3} + \dots = \dfrac{1}{1-ax}

 $$&lt;/p&gt;
&lt;p&gt;给定一个序列，写出他的生成函数是很容易的。尽管找到他的闭合形式不容易，但是我们一般不需要这样做。相反，我们需要考虑给定一个闭合形式，需要如何知道其对应的序列。&lt;/p&gt;
&lt;p&gt;我们约定 $ [x^{n}]G(x) $ 表示生成函数中 $ x^{n} $ 的系数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lect2-Probability Space</title>
      <link>https://diefish1024.github.io/posts/class-notes/math2701-probability-theory/lect2-probability-space/</link>
      <pubDate>Wed, 17 Sep 2025 09:53:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/math2701-probability-theory/lect2-probability-space/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;例题：在圆上“随机”选一段弧，问弧长大于圆周的 $ \frac{1}{3} $ 的概率？（&lt;a href=&#34;https://en.wikipedia.org/wiki/Bertrand_paradox_(probability)&#34;&gt;Bertrand paradox&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;至少三种自然的“均匀化”模型会给出不同答案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对弧长参数均匀（在 $ [0, 2\pi) $ 上均匀取长度，再随机起点）。&lt;/li&gt;
&lt;li&gt;对端点在圆上独立均匀（等价于随机两点确定弧，需指定取较短或较长弧）。&lt;/li&gt;
&lt;li&gt;对中心角或几何构造的中间量均匀（如均匀选角度后裁剪）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;核心问题：如何定义“随机”？不同“随机化”方案导致不同答案。&lt;/p&gt;
&lt;p&gt;讨论概率问题必须先明确概率空间（样本空间、事件族与概率测度），否则“概率”无从谈起。&lt;/p&gt;
&lt;h2 id=&#34;probability-space&#34;&gt;Probability Space&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个概率空间由三元组 $ (\Omega, \mathcal{F}, \mathbb{P}) $ 构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ \Omega $：样本空间（一次随机试验所有可能结果）。&lt;/li&gt;
&lt;li&gt;$ \mathcal{F} \subseteq 2^{\Omega} $：事件族（允许讨论与运算的集合）。&lt;/li&gt;
&lt;li&gt;$ \mathbb{P} : \mathcal{F} \to [0,1] $：概率测度（赋予事件概率）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记号说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ \Omega $：样本空间。&lt;/li&gt;
&lt;li&gt;$ 2^{\Omega} $：$ \Omega $ 的幂集（所有子集的集合）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么 $ \mathbb{P} $ 要定义在 $ \mathcal{F} $ 上而非直接在 $ \Omega $ 上？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;离散可数时，取 $ \mathcal{F} = 2^{\Omega} $ 可行，且对单点赋值即可确定所有事件的概率。&lt;/li&gt;
&lt;li&gt;连续时不同：单点的概率通常为 $ 0 $，但不可数并可有正概率；且 $ 2^{\Omega} $ 中存在不可测集合，无法一致赋值（见下文 Vitali set 与 Axiom of Choice）。因此需选择一个&lt;strong&gt;足够大又可控&lt;/strong&gt;的 $ \sigma $- 代数作为事件族。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sigma-algebra&#34;&gt;Sigma-Algebra&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;要求 $ \mathcal{F} $ 构成一个 $ \sigma $- 代数（域）：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Combinatorics HW1</title>
      <link>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/combinatorics-hw1/</link>
      <pubDate>Wed, 17 Sep 2025 09:45:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/combinatorics-hw1/</guid>
      <description>&lt;h2 id=&#34;problem-1&#34;&gt;Problem 1&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(1)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求
$$ 

\sum_{k=0}^{n} \binom{ 2n }{ 2k } 

 $$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$ 

\begin{align*}
 &amp; \sum_{k=0}^{n} (-1)^{k}\binom{ n }{ k } = 0 \\
\implies &amp; \sum_{k=0}^{2n} (-1)^{k}\binom{ 2n }{ k } =0 \\
\implies &amp; \sum_{k=0}^{2n} \binom{ 2n }{ 2k } = \sum_{k=1}^{2n} \binom{ 2n }{ 2k - 1 } 
\end{align*}

 $$
同时由于
$$ 

\sum_{k=0}^{2n} \binom{ 2n }{ 2k } + \sum_{k=1}^{2n} \binom{ 2n }{ 2k - 1 } = \sum_{k=0}^{2n} \binom{ 2n }{ k } = 2^{2n}

 $$
得到
$$ 

\sum_{k=0}^{2n} \binom{ 2n }{ 2k } = 2^{2n-1}

 $$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lect1-Counting</title>
      <link>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/lect1-counting/</link>
      <pubDate>Tue, 16 Sep 2025 13:22:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/cs0901-combinatorics/lect1-counting/</guid>
      <description>&lt;h2 id=&#34;product-and-sum-principles&#34;&gt;Product and Sum Principles&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加法原理（分类计数）&lt;/strong&gt;
若一个任务可分解为若干个互斥的子类，第 $ i $ 类有 $ a_i $ 种方案，则总数为 $ \sum_i a_i $。
解释：互斥保证不重不漏，求和即“或”的计数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;乘法原理（分步计数）&lt;/strong&gt;
若一个任务分为若干个有序步骤，步骤 $ i $ 有 $ b_i $ 种选择且相互独立，则总数为 $ \prod_i b_i $。
解释：有序步骤逐个做决定，“且”的计数对应乘法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;constructing-maps&#34;&gt;Constructing Maps&lt;/h2&gt;
&lt;p&gt;有些组合证明可以依赖于构造映射：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单射&lt;/strong&gt;：不同原像映到不同像，用于证明下界或“可嵌入性”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;满射&lt;/strong&gt;：像覆盖全体，用于证明上界可达或构造覆盖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双射&lt;/strong&gt;：建立集合 $ A $ 与 $ B $ 的一一对应，从而数 $ |A|=|B| $；这是“数某一个量 ⇒ 构造双射”的核心思想。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;twelvefoldway&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Twelvefold_way&#34;&gt;Twelvefoldway&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将 $ n $ 个球放入 $ m $ 个盒子，球与盒子可“可区分/不可区分”，以及盒子容量约束“任意/至多 1/至少 1”。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;$ n $&lt;/th&gt;
          &lt;th&gt;$ m $&lt;/th&gt;
          &lt;th&gt;任意&lt;/th&gt;
          &lt;th&gt;$ \leq 1 $&lt;/th&gt;
          &lt;th&gt;$ \geq 1 $&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;不同&lt;/td&gt;
          &lt;td&gt;不同&lt;/td&gt;
          &lt;td&gt;$ m^{n} $&lt;/td&gt;
          &lt;td&gt;$ m^{\underline{n}} $&lt;/td&gt;
          &lt;td&gt;$ m!\left\{ {n \atop m} \right\} $&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;同&lt;/td&gt;
          &lt;td&gt;不同&lt;/td&gt;
          &lt;td&gt;$ \binom{ n+m-1 }{ m-1 } $&lt;/td&gt;
          &lt;td&gt;$ \binom{ m }{ n } $&lt;/td&gt;
          &lt;td&gt;$ \binom{ n-1 }{ m-1 } $&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;不同&lt;/td&gt;
          &lt;td&gt;同&lt;/td&gt;
          &lt;td&gt;$ \sum_{k=0}^{\min(n,m)} \left\{ {n \atop k} \right\} $&lt;/td&gt;
          &lt;td&gt;$ [n \leq m] $&lt;/td&gt;
          &lt;td&gt;$ \left\{ {n \atop m} \right\} $&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;同&lt;/td&gt;
          &lt;td&gt;同&lt;/td&gt;
          &lt;td&gt;$ p_{\leq m}(n) $&lt;/td&gt;
          &lt;td&gt;$ [n \leq m] $&lt;/td&gt;
          &lt;td&gt;$ p(n,m) $&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;“把 $ n $ 个不同球分成 $ k $ 个非空无序盒”对应第二类斯特林数 $ \left\{ {n \atop k} \right\} $。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lect1-Introduction</title>
      <link>https://diefish1024.github.io/posts/class-notes/math2701-probability-theory/lect1-introduction/</link>
      <pubDate>Mon, 15 Sep 2025 10:47:00 +0800</pubDate>
      <guid>https://diefish1024.github.io/posts/class-notes/math2701-probability-theory/lect1-introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://chihaozhang.com/teaching/Prob2025/lectures/lec1/lec1.html&#34;&gt;课程讲义&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这门课里，我们会专注于所谓的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Probability_axioms&#34;&gt;科尔莫哥洛夫（Kolmogorov）的公理体系&lt;/a&gt;，它使得我们能够使用数学分析的工具来研究概率。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;stpetersburg-paradox&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/St._Petersburg_paradox&#34;&gt;St. Petersburg Paradox&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;圣彼得堡悖论。假设一个基于抛硬币赌博的游戏，庄家会一直扔硬币直到结果是正面，如果扔了 $ k $ 次，那么就会给玩家 $ 2^{k} $ 元的奖金。现在的问题是你愿意花多少钱来购买一次玩这个游戏的机会。&lt;/p&gt;
&lt;p&gt;一个很自然的想法是计算游戏的期望，那么我们很容易发现期望收益是
$$ 

\sum_{k \geq  1} 2^{k}\cdot 2^{-k} = 1 + 1 + \dots = +\infty

 $$
这说明平均每一轮我们的收益是无穷大，然而在现实生活中你真的愿意花大价钱去玩这个游戏吗？或者可以写一个简单的程序模拟一下就会发现，在比如门票定为 $ 100 $ 元，玩几百局，还是会轻易地输掉几万块钱。我们生活中一个常见的直觉是如果重复一个随机过程足够多次，平均收益就会逐渐趋近于期望收益，这在概率论中叫做&lt;strong&gt;大数定律（&lt;a href=&#34;https://en.wikipedia.org/wiki/Law_of_large_numbers&#34;&gt;Law of large numbers&lt;/a&gt;）&lt;/strong&gt;，但是在现实生活中我们并没有能力重复足够多游戏轮数去达到这个期望值。那么现在的问题就是如果定价用 $ a\cdot n $ 元来购买 $ n $ 次游戏机会，$ a $ 定为多少是合理的？&lt;/p&gt;
&lt;p&gt;用这门课中后续会学习到的数学工具，我们可以得到答案为 $ \log n $ （这个结果也符合我们实际的直觉）。&lt;/p&gt;
&lt;h2 id=&#34;随机游走&#34;&gt;随机游走&lt;/h2&gt;
&lt;p&gt;对二维随机游走问题的一个简化的建模是在 $ \mathbb{Z}^{2} $ 的网格上随机游走，从原点 $ (0,0) $ 出发，每次以 $ \dfrac{1}{4} $ 的概率往上下左右四个方向移动。我们现在询问，这个随机游走的路径是否会无数次回到原点？用 $ T $ 来表示第一次回到原点的时间，那么可以证明无数次回到原点等价于 $ \mathbb{P}[T &lt; \infty] = 1 $ ，也就是 $ T $ 以 $ 1 $ 的概率是有限的，当然目前只能从直觉上去理解，这个写法需要在后续的课程中去严格定义。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
